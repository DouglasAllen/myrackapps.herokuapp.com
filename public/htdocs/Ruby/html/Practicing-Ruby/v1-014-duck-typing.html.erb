<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/>
  <title>Practicing Ruby</title>
  <style>
    body {
      font-family: "Helvetica Neue", arial, sans-serif;
      font-size: 14px;
      line-height: 1.6;
      padding-top: 10px;
      padding-bottom: 10px;
      background-color: white;
      padding: 30px;
      color: #333;
      border: 1px solid #aaa;
      max-width: 900px;
      margin: 20px auto;
    }

    body > *:first-child {
      margin-top: 0 !important;
    }

    body > *:last-child {
      margin-bottom: 0 !important;
    }

    a {
      color: #4183C4;
      text-decoration: none;
    }

    a.absent {
      color: #cc0000;
    }

    a.anchor {
      display: block;
      padding-left: 30px;
      margin-left: -30px;
      cursor: pointer;
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
    }

    h1, h2, h3, h4, h5, h6 {
      margin: 20px 0 10px;
      padding: 0;
      font-weight: bold;
      -webkit-font-smoothing: antialiased;
      cursor: text;
      position: relative;
    }

    h2:first-child, h1:first-child, h1:first-child + h2, h3:first-child, h4:first-child, h5:first-child, h6:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
      text-decoration: none;
    }

    h1 tt, h1 code {
      font-size: inherit;
    }

    h2 tt, h2 code {
      font-size: inherit;
    }

    h3 tt, h3 code {
      font-size: inherit;
    }

    h4 tt, h4 code {
      font-size: inherit;
    }

    h5 tt, h5 code {
      font-size: inherit;
    }

    h6 tt, h6 code {
      font-size: inherit;
    }

    h1 {
      font-size: 28px;
      color: black;
    }

    h2 {
      font-size: 24px;
      border-bottom: 1px solid #cccccc;
      color: black;
    }

    h3 {
      font-size: 18px;
    }

    h4 {
      font-size: 16px;
    }

    h5 {
      font-size: 14px;
    }

    h6 {
      color: #777777;
      font-size: 14px;
    }

    p, blockquote, ul, ol, dl, li, table, pre {
      margin: 3px 0;
    }

    hr {
      background: transparent url("http://tinyurl.com/bq5kskr") repeat-x 0 0;
      border: 0 none;
      color: #cccccc;
      height: 4px;
      padding: 0;
    }

    body > h2:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    body > h1:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    body > h1:first-child + h2 {
      margin-top: 0;
      padding-top: 0;
    }

    body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
      margin-top: 0;
      padding-top: 0;
    }

    h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
      margin-top: 0;
    }

    li p.first {
      display: inline-block;
    }

    ul, ol {
      padding-left: 30px;
    }

    ul :first-child, ol :first-child {
      margin-top: 0;
    }

    ul :last-child, ol :last-child {
      margin-bottom: 0;
    }

    dl {
      padding: 0;
    }

    dl dt {
      font-size: 14px;
      font-weight: bold;
      font-style: italic;
      padding: 0;
      margin: 15px 0 5px;
    }

    dl dt:first-child {
      padding: 0;
    }

    dl dt > :first-child {
      margin-top: 0;
    }

    dl dt > :last-child {
      margin-bottom: 0;
    }

    dl dd {
      margin: 0 0 15px;
      padding: 0 15px;
    }

    dl dd > :first-child {
      margin-top: 0;
    }

    dl dd > :last-child {
      margin-bottom: 0;
    }

    blockquote {
      border-left: 4px solid #dddddd;
      padding: 0 15px;
      color: #777777;
    }

    blockquote > :first-child {
      margin-top: 0;
    }

    blockquote > :last-child {
      margin-bottom: 0;
    }

    table {
      padding: 0;
    }
    table tr {
      border-top: 1px solid #cccccc;
      background-color: white;
      margin: 0;
      padding: 0;
    }

    table tr:nth-child(2n) {
      background-color: #f8f8f8;
    }

    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      text-align: left;
      margin: 0;
      padding: 6px 13px;
    }

    table tr td {
      border: 1px solid #cccccc;
      text-align: left;
      margin: 0;
      padding: 6px 13px;
    }

    table tr th :first-child, table tr td :first-child {
      margin-top: 0;
    }

    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0;
    }

    img {
      max-width: 100%;
    }

    span.frame {
      display: block;
      overflow: hidden;
    }

    span.frame > span {
      border: 1px solid #dddddd;
      display: block;
      float: left;
      overflow: hidden;
      margin: 13px 0 0;
      padding: 7px;
      width: auto;
    }

    span.frame span img {
      display: block;
      float: left;
    }

    span.frame span span {
      clear: both;
      color: #333333;
      display: block;
      padding: 5px 0 0;
    }

    span.align-center {
      display: block;
      overflow: hidden;
      clear: both;
    }

    span.align-center > span {
      display: block;
      overflow: hidden;
      margin: 13px auto 0;
      text-align: center;
    }

    span.align-center span img {
      margin: 0 auto;
      text-align: center;
    }

    span.align-right {
      display: block;
      overflow: hidden;
      clear: both;
    }

    span.align-right > span {
      display: block;
      overflow: hidden;
      margin: 13px 0 0;
      text-align: right;
    }

    span.align-right span img {
      margin: 0;
      text-align: right;
    }

    span.float-left {
      display: block;
      margin-right: 13px;
      overflow: hidden;
      float: left;
    }

    span.float-left span {
      margin: 13px 0 0;
    }

    span.float-right {
      display: block;
      margin-left: 13px;
      overflow: hidden;
      float: right;
    }

    span.float-right > span {
      display: block;
      overflow: hidden;
      margin: 13px auto 0;
      text-align: right;
    }

    code, tt {
      font-family: "Lucida Console", "Courier New", courier;
      font-size: 12px;
      margin: 0 2px;
      padding: 3px 5px;
      white-space: nowrap;
      border: 1px solid #eaeaea;
      background-color: #f8f8f8;
      border-radius: 3px;
    }

    pre code {
      margin: 0;
      padding: 0;
      white-space: pre;
      border: none;
      background: transparent;
    }

    .highlight pre {
      background-color: #f8f8f8;
      border: 1px solid #cccccc;
      font-size: 13px;
      line-height: 19px;
      overflow: auto;
      padding: 6px 10px;
      border-radius: 3px;
    }

    pre {
      background-color: #f8f8f8;
      border: 1px solid #cccccc;
      font-size: 13px;
      line-height: 19px;
      overflow: auto;
      padding: 6px 10px;
      border-radius: 3px;
    }

    pre code, pre tt {
      background-color: transparent;
      border: none;
    }

    span.line-numbers {
      margin-right: 10px;
    }

    img.logo {
      display: block;
      margin: 10px auto;
    }

    h1.logo {
      text-align: center;
      font-size: 40px;
    }
  </style>
</head>
<body>
  <div id="containter">
    <h1 class="logo">Practicing Ruby</h1>
    <img class="logo" src="../images/header.png" />
    <p>Type systems are a fundamental part of every programming language. In fact, the way a language designer approaches typing goes a long way towards outlining the way that thoughts are expressed in that language.</p>

<p>Statically typed languages like C++ and Java make us tend to think of objects as abstract data structures that fit within a neatly defined hierarchy. In these languages, there isn’t a major distinction between an object’s class and its type, as the two concepts are tied together directly at the implementation level. But the marriage of class and type found in these languages is not a universal law shared by all object oriented programming languages.</p>

<p>By contrast, Ruby’s dynamic nature facilitates a style of type system known as duck typing. In particular, duck typing breaks the strong association between an object’s class and its type by defining types based on what an object can do rather than what class it was born from. This subtle shift in semantics changes virtually everything about how you need to think about designing object oriented systems, making it a great topic for Practicing Ruby to cover.</p>

<p>While duck typing is possible in many other languages, Ruby is designed from the ground up to support this style of objected oriented design. In this issue, we will cover some of the options that are available to us for doing Ruby-style type checking. </p>

<h3 id="type-checking-techniques">Type Checking Techniques</h3>

<p>There are three common ways to do type checking in Ruby, two of which involve
duck typing, and one that does not. Here’s an example of the approach 
that does <em>not</em> involve duck typing.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">read_data</span>(source)
  <span style="color:#080;font-weight:bold">case</span> source
  <span style="color:#080;font-weight:bold">when</span> <span style="color:#036;font-weight:bold">String</span>
    <span style="color:#036;font-weight:bold">File</span>.read(source)
  <span style="color:#080;font-weight:bold">when</span> <span style="color:#036;font-weight:bold">IO</span>
    source.read
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>If you’ve been working with Ruby for a while, you’ve probably written code that
did type checking in this fashion. Ruby’s case statement is powerful, and
makes this sort of logic easy to write. Our <code>read_data()</code> function works as
expected in the following common scenarios:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>filename = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">foo.txt</span><span style="color:#710">&quot;</span></span>
read_data(filename) <span style="color:#777">#=&gt; reads the contents of foo.txt by calling </span>
                    <span style="color:#777">#   File.read()</span>


input = <span style="color:#036;font-weight:bold">File</span>.open(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">foo.txt</span><span style="color:#710">&quot;</span></span>)
read_data(input) <span style="color:#777">#=&gt; reads the contents of foo.txt via </span>
                 <span style="color:#777">#   the passed in file handle</span>
</pre></div>
</div>
</div>

<p>But things begin to fall apart a bit when we decide we’d like <code>read_data()</code> to
work with a <code>Tempfile</code>, or with a <code>StringIO</code> object, or perhaps with a mock
object we’ve defined in our tests. We have baked into our logic the assumption that the input is always either a descendent of <code>String</code> or a descendent of <code>IO</code>. The purpose of duck typing is to remove these restrictions by focusing only on the messages that are being passed back and forth between objects rather than what class they belong to. The code below demonstrates one way you can do that.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">read_data</span>(source)
  <span style="color:#080;font-weight:bold">return</span> source.read <span style="color:#080;font-weight:bold">if</span> source.respond_to?(<span style="color:#A60">:read</span>)
  <span style="color:#080;font-weight:bold">return</span> <span style="color:#036;font-weight:bold">File</span>.read(source.to_str) <span style="color:#080;font-weight:bold">if</span> source.respond_to?(<span style="color:#A60">:to_str</span>)
  raise <span style="color:#036;font-weight:bold">ArgumentError</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>With this modification, our method expects far less of its input. The passed in
object simply needs to implement either a meaningful <code>read()</code> or <code>to_str()</code>
method. In addition to being backwards compatible with our non-duck-typed code,
this new approach gives us access to many useful standin objects, including: <code>StringIO</code>, <code>Tempfile</code>, mock objects for testing, and any user defined objects that are either IO-like or String-like but not a descendent of either.</p>

<p>However, the following contrived example illustrates a final corner case that calls for a bit of extreme duck typing to resolve. Try to spot the problem before reading about how to solve it.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">FileProxy</span>
  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">initialize</span>(tempfile)
    <span style="color:#33B">@tempfile</span> = tempfile
  <span style="color:#080;font-weight:bold">end</span>

  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">method_missing</span>(id, *args, &amp;block)
    <span style="color:#33B">@tempfile</span>.send(id, *args, &amp;block)
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>This code implements a proxy which forwards all of its messages to the wrapped <code>tempfile</code> object. However, like many hastily coded proxy objects in Ruby, it does not properly forward <code>respond_to?()</code> calls to the object it wraps. The irb session below illustrates the resulting false negative in our test.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#777"># Populate our tempfile through the proxy</span>

&gt;&gt; proxy = <span style="color:#036;font-weight:bold">FileProxy</span>.new(<span style="color:#036;font-weight:bold">Tempfile</span>.new(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">foo.txt</span><span style="color:#710">&quot;</span></span>))
=&gt; <span style="color:#777">#&lt;FileProxy:0x39461c @tempfile=#&lt;File:/var/f..foo.txt.7910.3&gt;&gt;</span>
&gt;&gt; proxy &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">foo bar baz</span><span style="color:#710">&quot;</span></span>
=&gt; <span style="color:#777">#&lt;File:/var/folders/sJ/sJo0IkPYFWCY3t5uH+gi0++++TQ/-Tmp-/foo.txt.7910.3&gt;</span>
&gt;&gt; proxy.rewind
=&gt; <span style="color:#00D">0</span>

<span style="color:#777"># Unsuccessfully test for presence of read() method</span>

&gt;&gt; proxy.respond_to?(<span style="color:#A60">:read</span>)
=&gt; <span style="color:#069">false</span>

<span style="color:#777"># But read() works as expected!</span>

&gt;&gt; proxy.read
=&gt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">foo bar baz</span><span style="color:#710">&quot;</span></span>
</pre></div>
</div>
</div>

<p>This issue will cause <code>read_data()</code> to raise an <code>ArgumentError</code> when passed a <code>FileProxy</code>. In this case, the best solution is to fix <code>respond_to?()</code> so that it works as expected, but since you may often encounter libraries with bad behaviors like this, it’s worth knowing what the duck typing fundamentalist would do in this situation.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">read_data</span>(source)
  <span style="color:#080;font-weight:bold">begin</span> 
    <span style="color:#080;font-weight:bold">return</span> source.read 
  <span style="color:#080;font-weight:bold">rescue</span> <span style="color:#036;font-weight:bold">NoMethodError</span>
    <span style="color:#777"># do nothing, just catch the specific error you'd expect if</span>
    <span style="color:#777"># read() was not present.</span>
  <span style="color:#080;font-weight:bold">end</span>

  <span style="color:#080;font-weight:bold">begin</span>
    <span style="color:#036;font-weight:bold">File</span>.read(source.to_str)
  <span style="color:#080;font-weight:bold">rescue</span> <span style="color:#036;font-weight:bold">NoMethodError</span>
    raise <span style="color:#036;font-weight:bold">ArgumentError</span> <span style="color:#777"># now we've run out of valid cases, so let's</span>
                        <span style="color:#777"># raise a meaningful error</span>
   <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>With this final version, we preserve all the benefits of the previous duck
typing example, but we can work with objects that have dishonest <code>respond_to?()</code>
methods. Unfortunately, the cost for such flexibility includes code that is less
pleasant to read and is almost certainly going to run slower than either of our
previous implementations. Using the exception system for control flow isn’t cheap, 
even if this is the most ‘pure’ form of type checking we can do.</p>

<p>While we’ve talked about the benefits and drawbacks of each of these approaches, I haven’t given any direct advice on whether one way of doing type checking is better than the others, simply because there is no simple answer to that question.</p>

<p>I will paint a clearer picture in the next article by showing several
realistic examples of why duck typing can come in handy. Until then, I will
leave you with a few things to think about.</p>

<h3 id="questions--study-topics">Questions / Study Topics</h3>

<ul>
  <li>
    <p>Is explicit class checking ever absolutely necessary? Are their situations in which even if other options are available, checking the class of an object is still the best thing to do?</p>
  </li>
  <li>
    <p>Name something weird that can happen when you write your contracts on the messages your objects respond to rather than what class of object they are.</p>
  </li>
  <li>
    <p>Try to identify some feature of Ruby that relies on duck typing either for its basic functionality or as an extension point meant to be customized by application programmers.</p>
  </li>
  <li>
    <p>Share a bit of code which does explicit class comparison that you think would be very difficult to convert to a duck-typing style.</p>
  </li>
  <li>
    <p>Share a bit of code (either your own or from a OSS project you like) that you feel uses duck typing effectively.</p>
  </li>
</ul>

<p>Feel free to leave a comment below if any of the above topics interest you.</p>

<blockquote>
  <p><strong>NOTE:</strong> This article has also been published on the Ruby Best Practices blog. There <a href="http://blog.rubybestpractices.com/posts/gregory/046-issue-14-duck-typing.html#disqus_thread">may be additional commentary</a> 
over there worth taking a look at.</p>
</blockquote>

  </div>
</body>
</html>

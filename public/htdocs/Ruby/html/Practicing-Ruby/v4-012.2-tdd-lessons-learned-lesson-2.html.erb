<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/>
  <title>Practicing Ruby</title>
  <style>
    body {
      font-family: "Helvetica Neue", arial, sans-serif;
      font-size: 14px;
      line-height: 1.6;
      padding-top: 10px;
      padding-bottom: 10px;
      background-color: white;
      padding: 30px;
      color: #333;
      border: 1px solid #aaa;
      max-width: 900px;
      margin: 20px auto;
    }

    body > *:first-child {
      margin-top: 0 !important;
    }

    body > *:last-child {
      margin-bottom: 0 !important;
    }

    a {
      color: #4183C4;
      text-decoration: none;
    }

    a.absent {
      color: #cc0000;
    }

    a.anchor {
      display: block;
      padding-left: 30px;
      margin-left: -30px;
      cursor: pointer;
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
    }

    h1, h2, h3, h4, h5, h6 {
      margin: 20px 0 10px;
      padding: 0;
      font-weight: bold;
      -webkit-font-smoothing: antialiased;
      cursor: text;
      position: relative;
    }

    h2:first-child, h1:first-child, h1:first-child + h2, h3:first-child, h4:first-child, h5:first-child, h6:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
      text-decoration: none;
    }

    h1 tt, h1 code {
      font-size: inherit;
    }

    h2 tt, h2 code {
      font-size: inherit;
    }

    h3 tt, h3 code {
      font-size: inherit;
    }

    h4 tt, h4 code {
      font-size: inherit;
    }

    h5 tt, h5 code {
      font-size: inherit;
    }

    h6 tt, h6 code {
      font-size: inherit;
    }

    h1 {
      font-size: 28px;
      color: black;
    }

    h2 {
      font-size: 24px;
      border-bottom: 1px solid #cccccc;
      color: black;
    }

    h3 {
      font-size: 18px;
    }

    h4 {
      font-size: 16px;
    }

    h5 {
      font-size: 14px;
    }

    h6 {
      color: #777777;
      font-size: 14px;
    }

    p, blockquote, ul, ol, dl, li, table, pre {
      margin: 3px 0;
    }

    hr {
      background: transparent url("http://tinyurl.com/bq5kskr") repeat-x 0 0;
      border: 0 none;
      color: #cccccc;
      height: 4px;
      padding: 0;
    }

    body > h2:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    body > h1:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    body > h1:first-child + h2 {
      margin-top: 0;
      padding-top: 0;
    }

    body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
      margin-top: 0;
      padding-top: 0;
    }

    h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
      margin-top: 0;
    }

    li p.first {
      display: inline-block;
    }

    ul, ol {
      padding-left: 30px;
    }

    ul :first-child, ol :first-child {
      margin-top: 0;
    }

    ul :last-child, ol :last-child {
      margin-bottom: 0;
    }

    dl {
      padding: 0;
    }

    dl dt {
      font-size: 14px;
      font-weight: bold;
      font-style: italic;
      padding: 0;
      margin: 15px 0 5px;
    }

    dl dt:first-child {
      padding: 0;
    }

    dl dt > :first-child {
      margin-top: 0;
    }

    dl dt > :last-child {
      margin-bottom: 0;
    }

    dl dd {
      margin: 0 0 15px;
      padding: 0 15px;
    }

    dl dd > :first-child {
      margin-top: 0;
    }

    dl dd > :last-child {
      margin-bottom: 0;
    }

    blockquote {
      border-left: 4px solid #dddddd;
      padding: 0 15px;
      color: #777777;
    }

    blockquote > :first-child {
      margin-top: 0;
    }

    blockquote > :last-child {
      margin-bottom: 0;
    }

    table {
      padding: 0;
    }
    table tr {
      border-top: 1px solid #cccccc;
      background-color: white;
      margin: 0;
      padding: 0;
    }

    table tr:nth-child(2n) {
      background-color: #f8f8f8;
    }

    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      text-align: left;
      margin: 0;
      padding: 6px 13px;
    }

    table tr td {
      border: 1px solid #cccccc;
      text-align: left;
      margin: 0;
      padding: 6px 13px;
    }

    table tr th :first-child, table tr td :first-child {
      margin-top: 0;
    }

    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0;
    }

    img {
      max-width: 100%;
    }

    span.frame {
      display: block;
      overflow: hidden;
    }

    span.frame > span {
      border: 1px solid #dddddd;
      display: block;
      float: left;
      overflow: hidden;
      margin: 13px 0 0;
      padding: 7px;
      width: auto;
    }

    span.frame span img {
      display: block;
      float: left;
    }

    span.frame span span {
      clear: both;
      color: #333333;
      display: block;
      padding: 5px 0 0;
    }

    span.align-center {
      display: block;
      overflow: hidden;
      clear: both;
    }

    span.align-center > span {
      display: block;
      overflow: hidden;
      margin: 13px auto 0;
      text-align: center;
    }

    span.align-center span img {
      margin: 0 auto;
      text-align: center;
    }

    span.align-right {
      display: block;
      overflow: hidden;
      clear: both;
    }

    span.align-right > span {
      display: block;
      overflow: hidden;
      margin: 13px 0 0;
      text-align: right;
    }

    span.align-right span img {
      margin: 0;
      text-align: right;
    }

    span.float-left {
      display: block;
      margin-right: 13px;
      overflow: hidden;
      float: left;
    }

    span.float-left span {
      margin: 13px 0 0;
    }

    span.float-right {
      display: block;
      margin-left: 13px;
      overflow: hidden;
      float: right;
    }

    span.float-right > span {
      display: block;
      overflow: hidden;
      margin: 13px auto 0;
      text-align: right;
    }

    code, tt {
      font-family: "Lucida Console", "Courier New", courier;
      font-size: 12px;
      margin: 0 2px;
      padding: 3px 5px;
      white-space: nowrap;
      border: 1px solid #eaeaea;
      background-color: #f8f8f8;
      border-radius: 3px;
    }

    pre code {
      margin: 0;
      padding: 0;
      white-space: pre;
      border: none;
      background: transparent;
    }

    .highlight pre {
      background-color: #f8f8f8;
      border: 1px solid #cccccc;
      font-size: 13px;
      line-height: 19px;
      overflow: auto;
      padding: 6px 10px;
      border-radius: 3px;
    }

    pre {
      background-color: #f8f8f8;
      border: 1px solid #cccccc;
      font-size: 13px;
      line-height: 19px;
      overflow: auto;
      padding: 6px 10px;
      border-radius: 3px;
    }

    pre code, pre tt {
      background-color: transparent;
      border: none;
    }

    span.line-numbers {
      margin-right: 10px;
    }

    img.logo {
      display: block;
      margin: 10px auto;
    }

    h1.logo {
      text-align: center;
      font-size: 40px;
    }
  </style>
</head>
<body>
  <div id="containter">
    <h1 class="logo">Practicing Ruby</h1>
    <img class="logo" src="../images/header.png" />
    <blockquote>
  <p><strong>NOTE</strong>: This is one of <a href="http://practicingruby.com/articles/65">four lessons learned</a> 
from my <a href="http://practicingruby.com/articles/28">90 day self-study on test-driven development</a>. 
If this topic interests you,  be sure to check out the other lessons! </p>
</blockquote>

<p>To maintain a productive TDD workflow, you need understand the difference
between <strong>refactoring</strong> and <strong>redesign</strong>. These two activities are distinct from one
another, but because they are often done in lockstep, it can be 
challenging to mentally separate them. </p>

<p>The problem I noticed in my own work is that seemingly simple changes
often spiral into much more complex modifications. Whenever that happens,
it is easy to make bad decisions that can cause progress to grind to a halt. 
Having a good way to distinguish between what can be accomplished
via simple refactorings and what requires careful design consideration 
seems to be the key to preventing this problem.</p>

<p>My hope is that by reading what I have learned from my own experiences,
you will be able to avoid some of these obstacles along your own path. 
These lessons are not fun to learn the hard way!</p>

<h3 id="what-is-refactoring">What is refactoring?</h3>

<p>Refactoring in the traditional sense has to do with making <a href="http://refactoring.com/catalog/index.html">small and safe 
transformations</a> to a codebase 
without altering its external behavior. Because refactorings are designed to be atomic 
and almost trivial, you can apply them whenever you feel that they will make life
 easier for you down the road. For example, it is rarely a bad idea to clean up messy
 code by introducing a couple helper methods:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>       def belongs_to(parent, params)
<span style="background:hsla(0,100%,50%,0.12)" class="line"><span style="color:#c00;background:transparent;font-weight:bold">-</span>        mapper.record_class.send(:define_method, parent) do</span>
<span style="background:hsla(0,100%,50%,0.12)" class="line"><span style="color:#c00;background:transparent;font-weight:bold">-</span>          Object.const_get(params[:class]).find(send(params[:key]))</span>
<span style="background:hsla(120,100%,50%,0.12)" class="line"><span style="color:#0c0;background:transparent;font-weight:bold">+</span>        define_association(parent) do</span>
<span style="background:hsla(120,100%,50%,0.12)" class="line"><span style="color:#0c0;background:transparent;font-weight:bold">+</span>          BrokenRecord.string_to_constant(params[:class])</span>
<span style="background:hsla(120,100%,50%,0.12)" class="line"><span style="color:#0c0;background:transparent;font-weight:bold">+</span>                      .find(send(params[:key]))</span>
         end
       end
 
       def has_many(children, params)
         table_primary_key = mapper.primary_key
 
<span style="background:hsla(0,100%,50%,0.12)" class="line"><span style="color:#c00;background:transparent;font-weight:bold">-</span>        <span style="background-color:hsla(0,100%,50%,0.2);border:1pxsolidhsla(0,100%,45%,0.5);margin:-1px;border-bottom:none;border-top-left-radius:5px;border-top-right-radius:5px">mapper.record_class.send(:define_method, </span>children) do</span>
<span style="background:hsla(0,100%,50%,0.12)" class="line"><span style="color:#c00;background:transparent;font-weight:bold">-</span>          <span style="background-color:hsla(0,100%,50%,0.2);border:1pxsolidhsla(0,100%,45%,0.5);margin:-1px;border-bottom:none;border-top-left-radius:5px;border-top-right-radius:5px">Object.const_ge</span>t(params[:class])</span>
<span style="background:hsla(0,100%,50%,0.12)" class="line"><span style="color:#c00;background:transparent;font-weight:bold">-</span>            <span style="background-color:hsla(0,100%,50%,0.2);border:1pxsolidhsla(0,100%,45%,0.5);margin:-1px;border-bottom:none;border-top-left-radius:5px;border-top-right-radius:5px">    </span>.where(params[:key] =&gt; send(table_primary_key))</span>
<span style="background:hsla(120,100%,50%,0.12)" class="line"><span style="color:#0c0;background:transparent;font-weight:bold">+</span>        <span style="background-color:hsla(120,100%,50%,0.2);border:1pxsolidhsla(120,100%,25%,0.5);margin:-1px;border-top:none;border-bottom-left-radius:5px;border-bottom-right-radius:5px">define_association(</span>children) do</span>
<span style="background:hsla(120,100%,50%,0.12)" class="line"><span style="color:#0c0;background:transparent;font-weight:bold">+</span>          <span style="background-color:hsla(120,100%,50%,0.2);border:1pxsolidhsla(120,100%,25%,0.5);margin:-1px;border-top:none;border-bottom-left-radius:5px;border-bottom-right-radius:5px">BrokenRecord.string_to_constan</span>t(params[:class])</span>
<span style="background:hsla(120,100%,50%,0.12)" class="line"><span style="color:#0c0;background:transparent;font-weight:bold">+</span>            .where(params[:key] =&gt; send(table_primary_key))</span>
         end
       end
 ~~~
 
<span style="color:#777" class="line">On the surface, this change is very superficial, as a proper refactoring ought</span>
<span style="color:#777" class="line">to be. However, it has several immediate advantages worth pointing out:</span>

<span style="color:#777" class="line">* The `define_association` helper makes the code reveal its </span>
<span style="color:#777" class="line">intentions much more clearly by hiding some awkward metaprogramming.</span>

<span style="color:#777" class="line">* The `BrokenRecord.string_to_constant` method makes it easy</span>
<span style="color:#777" class="line">to extend this code so that it handles fully qualified constant names </span>
<span style="color:#777" class="line">(i.e. `SomeProject::Person`), without the need to add a bunch of extra </span>
<span style="color:#777" class="line">noise in multiple places.</span>

<span style="color:#777" class="line">* Both helper methods cut down on duplication, eliminating the connascence</span>
<span style="color:#777" class="line">of algorithm that was present in the original code.</span>

<span style="color:#777" class="line">* Both helper methods reduce the amount of implementation details that</span>
<span style="color:#777" class="line">the `belongs_to` and `has_many` methods need to be directly aware of,</span>
<span style="color:#777" class="line">making them more adaptive to future changes.</span>

<span style="color:#777" class="line">The important thing to notice here is that while making this change opens</span>
<span style="color:#777" class="line">a lot of doors for us, and has some immediate tangible benefits, it does </span>
<span style="color:#777" class="line">not introduce any observable functional changes, both from the external</span>
<span style="color:#777" class="line">perspective, and from the perspective of the object's collaborators.</span>

<span style="color:#777" class="line">### What is redesign?</span>

<span style="color:#777" class="line">While the concept of refactoring is easy to define and categorize, the</span>
<span style="color:#777" class="line">process of redesigning code is not nearly as straightforward. Rather</span>
<span style="color:#777" class="line">than attempting to provide an awkard definition for it, I will</span>
<span style="color:#777" class="line">demonstrate what makes redesign different from refactoring by</span>
<span style="color:#777" class="line">showing you a real example from my study.</span>

<span style="color:#777" class="line">When working on BrokenRecord (my toy implementation of </span>
<span style="color:#777" class="line">the Active Record pattern), I initially designed it so that a </span>
<span style="color:#777" class="line">single object was responsible for running queries against</span>
<span style="color:#777" class="line">the database and mapping their results to user-defined </span>
<span style="color:#777" class="line">models. This worked fine as a proof of concept, and the</span>
<span style="color:#777" class="line">[code was pretty easy to follow](https://github.com/elm-city-craftworks/broken_record/blob/e5bd9fb676361b97c9c27d46efd812b826eecbf6/lib/broken_record/table.rb).</span>

<span style="color:#777" class="line">However, designing things this way lead to very high</span>
<span style="color:#777" class="line">coupling between the query API and the underlying</span>
<span style="color:#777" class="line">database implementation, as you can see in the following</span>
<span style="color:#777" class="line">code:</span>

<span style="color:#777" class="line">~~~ruby</span>
<span style="color:#777" class="line">module BrokenRecord</span>
  class Table
  
   #...

    def create(params)
      escapes = params.count.times.map { &quot;?&quot; }.join(&quot;, &quot;) 
      fields  = params.keys.join(&quot;, &quot;)

      BrokenRecord.database.execute(
        &quot;insert into #{@table_name} (#{fields}) values (#{escapes})&quot;,
        params.values
      )
    end

    def find(id)
      BrokenRecord.database
                  .execute(&quot;select * from #{@table_name} where id = ?&quot;, [id])
                  .map { |r| @row_builder.build_row(self, r) }.first
    end
  end
<span style="color:#777" class="line">end</span>
</pre></div>
</div>
</div>

<p>Even though I had no intentions of making BrokenRecord into a 
library that could be used for practical applications, this design was
fundamentally inconsistent with what it means to be an 
object-relational mapper. The lack of abstraction made any sort
of query optimization impossible, and also prevented the 
possibility of introducing support for multiple database backends.</p>

<p>In addition to these concerns about future extensibility, the current
design made it much harder to test this code, and much harder
to do some common queries without directly hijacking the global 
reference to the underlying database adapter. All these things 
combined meant that a redesign was clearly in order.</p>

<p>Taking a first glance at the implementation of 
<a href="https://github.com/elm-city-craftworks/broken_record/blob/e5bd9fb676361b97c9c27d46efd812b826eecbf6/lib/broken_record/table.rb">BrokenRecord::Table</a>,
it was tempting to think that all that was needed here was to <a href="http://refactoring.com/catalog/extractClass.html">extract
a class</a> to encapsulate the 
database interactions. But because this object had come into existence as
a result of a <a href="https://github.com/elm-city-craftworks/broken_record/blob/e5bd9fb676361b97c9c27d46efd812b826eecbf6/test/integration.rb">broad-based integration test</a>
 rather than a series of focused unit tests, I was hesitant to perform an extraction 
 without writing a few more tests first.</p>

<p>Thinking about the problem a little more, I noticed that the changes I wanted
 were deeper than just putting together an internal object to hide
 some implementation details and reduce coupling. The fact that <code>Table</code> was
 the best name I could think of for my extracted object even though that was
 the name of the original class was a sign that I was in the process of 
 changing some responsibilities in the system, not just grouping related
 bits of functionality together.</p>

<h3 id="taking-a-tdd-friendly-approach-to-redesign">Taking a TDD-friendly approach to redesign</h3>

<p>The mistake I’ve made in the past when it comes to redesigning internal
objects is that I tended to make my changes recursively, often without
introducing new tests as I went. So for example, I might take a helper
object that had gotten too complex and break it into two objects, testing
both objects only indirectly through some higher level test. That kind of
change would often reveal to me that I wanted to extract even more classes
or methods, or possibly even change the protocols between the low-level 
collaborators in the system. </p>

<p>Sooner or later, I would end up with a complicated web of internal objects 
that were all being tested through a single use case at the high level, 
and so any defects I introduced became very hard to track down. Even though
my tests were protecting external defects from creeping into the system, 
I had negated the design and debugging benefits that come along with doing
TDD more rigorously.</p>

<p>After <a href="https://github.com/mendicant/mendicantuniversity.org/wiki/TDD-study-session-%282012-May-03%29">discussing this bad habit of mine with Eric Hodel</a>
during one of Mendicant University’s study sessions, I came to realize that 
there are some simple ways to sidestep this problem. In particular, I realized 
that I could redesign systems by introducing new components from the bottom 
up, cutting over to the new implementation only when it was ready to be integrated.</p>

<p>Wanting to try out these new ideas in BrokenRecord, I started out by renaming
the <code>BrokenRecord::Table</code> object to <code>BrokenRecord::RecordTable</code>. I put virtually
no thought into the new name, because what I was really trying to do was free
up the <code>BrokenRecord::Table</code> name so that I could completely change the
responsibilities associated with it. This allowed me to experience a similar
amount of freedom that simply deleting the original class would have given
me, but without the cost of having to work through a bunch of orphaned
references and broken tests in my system.</p>

<p>I drove the new <code>BrokenRecord::Table</code> object test first, mostly mirroring the
ideas from the original object but sticking strictly to the interactions with
the database and representing records as simple Hash objects. I also
added a new feature which provided information about the columns
in a given table. You can get a rough idea for how I sketched out that
feature by checking out the following test:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>  it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">must be able to retrieve column information</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">do</span>
    columns = table.columns

    columns.count.must_equal(<span style="color:#00D">3</span>)

    columns[<span style="color:#A60">:id</span>][<span style="color:#A60">:type</span>].must_equal(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">integer</span><span style="color:#710">&quot;</span></span>)
    columns[<span style="color:#A60">:title</span>][<span style="color:#A60">:type</span>].must_equal(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">text</span><span style="color:#710">&quot;</span></span>)
    columns[<span style="color:#A60">:body</span>][<span style="color:#A60">:type</span>].must_equal(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">text</span><span style="color:#710">&quot;</span></span>)
  <span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>The original <code>BrokenRecord::Table</code> object was just a first iteration spike,
and so it expected that all model objects explicitly defined what fields 
were in the tables they mapped to. This helped keep the implementation
simple, which was essential when the class was taking on two 
responsibilities at once. However, in the new <code>BrokenRecord::Table</code> 
object, this kind of low level database interaction looked perfectly at
home, and paved the way for removing the tedious <code>BrokenRecord::RowMapper</code>
object in the newly designed system.</p>

<p>Throughout the process of building better internals from the bottom
up, I was able to make these kinds of revisions to several objects, and
also introduced a couple more internal objects to help out with various
things. Sooner or later, I reached the point where I was ready to create
an object that could serve as a drop-in replacement for the original
<code>BrokenRecord::Table</code> object (the one I renamed <code>RecordTable</code>). 
Feeling like I might actually keep this new object around for a while, 
I decided to name it <code>TableMapper</code>, which at least sounded slightly
less horrible than <code>RecordTable</code>. Its methods ended up looking 
something this:</p>

<p>~~~ruby
module BrokenRecord
  class TableMapper</p>

<p># …</p>

<pre><code>def create(params)
  id = @table.insert(params)    

  find(id)
end

def find(id)
  fields = @table.where(:id =&gt; id).first

  return nil unless fields

  @record_class.new(:table =&gt; @table,
                    :fields =&gt; fields,
                    :key    =&gt; id)
end   end end ~~~
</code></pre>

<p>Functionality-wise, the newly created <code>BrokenRecord::TableMapper</code> was nearly a
drop in replacement for the original system, even though it had a much better
underlying design. Because it only needed to implement a handful of methods
to maintain API compatibility, integrating it went very smoothly, and required
almost no changes to the original top-level tests. Once I cut things over
and had all the tests passing, I was able to completely remove the
<code>BrokenRecord::RecordTable</code> object without any issues.</p>

<h3 id="reflections">Reflections</h3>

<p>If I had not taken this more disciplined approach and instead followed my old
ways, I probably would have ended up in about the same place design-wise, but
it would have come at a much higher cost. I would have had fewer tests,
spent more time debugging trivial errors, and probably would have cut corners
in places out of impatience or frustration. The overall codebase would have
still been quite brittle, and future changes would be harder to make rather
than easier. Taking that less disciplined approach might have allowed me
to implement this particular set of changes a little faster, but my past 
experiences have taught me that I always end up having to pay down
my techinical debt sooner or later.</p>

<p>By teaching myself to think of refactoring and redesign as distinct activities,
I am much more likely to stop myself from going on long exploratory cleanup
missions with little guidance from my tests. This has already made a big
difference in my own work, so I’d definitely recommend giving it a try.</p>

<p>If you have questions, or a story of your own to share, please leave me a comment!</p>


  </div>
</body>
</html>

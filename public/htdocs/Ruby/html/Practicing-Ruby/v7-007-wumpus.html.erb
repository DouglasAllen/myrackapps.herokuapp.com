<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/>
  <title>Practicing Ruby</title>
  <style>
    body {
      font-family: "Helvetica Neue", arial, sans-serif;
      font-size: 14px;
      line-height: 1.6;
      padding-top: 10px;
      padding-bottom: 10px;
      background-color: white;
      padding: 30px;
      color: #333;
      border: 1px solid #aaa;
      max-width: 900px;
      margin: 20px auto;
    }

    body > *:first-child {
      margin-top: 0 !important;
    }

    body > *:last-child {
      margin-bottom: 0 !important;
    }

    a {
      color: #4183C4;
      text-decoration: none;
    }

    a.absent {
      color: #cc0000;
    }

    a.anchor {
      display: block;
      padding-left: 30px;
      margin-left: -30px;
      cursor: pointer;
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
    }

    h1, h2, h3, h4, h5, h6 {
      margin: 20px 0 10px;
      padding: 0;
      font-weight: bold;
      -webkit-font-smoothing: antialiased;
      cursor: text;
      position: relative;
    }

    h2:first-child, h1:first-child, h1:first-child + h2, h3:first-child, h4:first-child, h5:first-child, h6:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
      text-decoration: none;
    }

    h1 tt, h1 code {
      font-size: inherit;
    }

    h2 tt, h2 code {
      font-size: inherit;
    }

    h3 tt, h3 code {
      font-size: inherit;
    }

    h4 tt, h4 code {
      font-size: inherit;
    }

    h5 tt, h5 code {
      font-size: inherit;
    }

    h6 tt, h6 code {
      font-size: inherit;
    }

    h1 {
      font-size: 28px;
      color: black;
    }

    h2 {
      font-size: 24px;
      border-bottom: 1px solid #cccccc;
      color: black;
    }

    h3 {
      font-size: 18px;
    }

    h4 {
      font-size: 16px;
    }

    h5 {
      font-size: 14px;
    }

    h6 {
      color: #777777;
      font-size: 14px;
    }

    p, blockquote, ul, ol, dl, li, table, pre {
      margin: 3px 0;
    }

    hr {
      background: transparent url("http://tinyurl.com/bq5kskr") repeat-x 0 0;
      border: 0 none;
      color: #cccccc;
      height: 4px;
      padding: 0;
    }

    body > h2:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    body > h1:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    body > h1:first-child + h2 {
      margin-top: 0;
      padding-top: 0;
    }

    body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
      margin-top: 0;
      padding-top: 0;
    }

    h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
      margin-top: 0;
    }

    li p.first {
      display: inline-block;
    }

    ul, ol {
      padding-left: 30px;
    }

    ul :first-child, ol :first-child {
      margin-top: 0;
    }

    ul :last-child, ol :last-child {
      margin-bottom: 0;
    }

    dl {
      padding: 0;
    }

    dl dt {
      font-size: 14px;
      font-weight: bold;
      font-style: italic;
      padding: 0;
      margin: 15px 0 5px;
    }

    dl dt:first-child {
      padding: 0;
    }

    dl dt > :first-child {
      margin-top: 0;
    }

    dl dt > :last-child {
      margin-bottom: 0;
    }

    dl dd {
      margin: 0 0 15px;
      padding: 0 15px;
    }

    dl dd > :first-child {
      margin-top: 0;
    }

    dl dd > :last-child {
      margin-bottom: 0;
    }

    blockquote {
      border-left: 4px solid #dddddd;
      padding: 0 15px;
      color: #777777;
    }

    blockquote > :first-child {
      margin-top: 0;
    }

    blockquote > :last-child {
      margin-bottom: 0;
    }

    table {
      padding: 0;
    }
    table tr {
      border-top: 1px solid #cccccc;
      background-color: white;
      margin: 0;
      padding: 0;
    }

    table tr:nth-child(2n) {
      background-color: #f8f8f8;
    }

    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      text-align: left;
      margin: 0;
      padding: 6px 13px;
    }

    table tr td {
      border: 1px solid #cccccc;
      text-align: left;
      margin: 0;
      padding: 6px 13px;
    }

    table tr th :first-child, table tr td :first-child {
      margin-top: 0;
    }

    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0;
    }

    img {
      max-width: 100%;
    }

    span.frame {
      display: block;
      overflow: hidden;
    }

    span.frame > span {
      border: 1px solid #dddddd;
      display: block;
      float: left;
      overflow: hidden;
      margin: 13px 0 0;
      padding: 7px;
      width: auto;
    }

    span.frame span img {
      display: block;
      float: left;
    }

    span.frame span span {
      clear: both;
      color: #333333;
      display: block;
      padding: 5px 0 0;
    }

    span.align-center {
      display: block;
      overflow: hidden;
      clear: both;
    }

    span.align-center > span {
      display: block;
      overflow: hidden;
      margin: 13px auto 0;
      text-align: center;
    }

    span.align-center span img {
      margin: 0 auto;
      text-align: center;
    }

    span.align-right {
      display: block;
      overflow: hidden;
      clear: both;
    }

    span.align-right > span {
      display: block;
      overflow: hidden;
      margin: 13px 0 0;
      text-align: right;
    }

    span.align-right span img {
      margin: 0;
      text-align: right;
    }

    span.float-left {
      display: block;
      margin-right: 13px;
      overflow: hidden;
      float: left;
    }

    span.float-left span {
      margin: 13px 0 0;
    }

    span.float-right {
      display: block;
      margin-left: 13px;
      overflow: hidden;
      float: right;
    }

    span.float-right > span {
      display: block;
      overflow: hidden;
      margin: 13px auto 0;
      text-align: right;
    }

    code, tt {
      font-family: "Lucida Console", "Courier New", courier;
      font-size: 12px;
      margin: 0 2px;
      padding: 3px 5px;
      white-space: nowrap;
      border: 1px solid #eaeaea;
      background-color: #f8f8f8;
      border-radius: 3px;
    }

    pre code {
      margin: 0;
      padding: 0;
      white-space: pre;
      border: none;
      background: transparent;
    }

    .highlight pre {
      background-color: #f8f8f8;
      border: 1px solid #cccccc;
      font-size: 13px;
      line-height: 19px;
      overflow: auto;
      padding: 6px 10px;
      border-radius: 3px;
    }

    pre {
      background-color: #f8f8f8;
      border: 1px solid #cccccc;
      font-size: 13px;
      line-height: 19px;
      overflow: auto;
      padding: 6px 10px;
      border-radius: 3px;
    }

    pre code, pre tt {
      background-color: transparent;
      border: none;
    }

    span.line-numbers {
      margin-right: 10px;
    }

    img.logo {
      display: block;
      margin: 10px auto;
    }

    h1.logo {
      text-align: center;
      font-size: 40px;
    }
  </style>
</head>
<body>
  <div id="containter">
    <h1 class="logo">Practicing Ruby</h1>
    <img class="logo" src="../images/header.png" />
    <p><a href="http://en.wikipedia.org/wiki/Hunt_the_Wumpus">Hunt the Wumpus</a> is a hide-and-seek game that takes place in an underground
cave network full of interconnected rooms. To win the game, the player
needs to locate the evil Wumpus and kill it while avoiding various different 
hazards that are hidden within in the cave.</p>

<p>Originally written by Gregory Yob in the 1970s, this game is traditionally
played using a text-based interface, which leaves plenty up to the
player’s imagination, and also makes programming easier for those who
want to build Wumpus-like games of their own.</p>

<p>Because of its simple but clever nature, Hunt the Wumpus has been ported 
to many different platforms and programming languages over the last several
decades. In this article, you will discover why this blast from the past 
serves as an excellent example of creative computing, and you’ll also 
learn how to implement it from scratch in Ruby.</p>

<h2 id="gameplay-demonstration">Gameplay demonstration</h2>

<p>There are only two actions available to the player throughout the game: to move
from room to room, or to shoot arrows into nearby rooms in an attempt to kill 
the Wumpus. Until the player knows for sure where the Wumpus is, most of their actions 
will be dedicated to moving around the cave to gain a sense of its layout:</p>

<pre><code>You are in room 1.
Exits go to: 2, 8, 5
-----------------------------------------
What do you want to do? (m)ove or (s)hoot? m
Where? 2
-----------------------------------------
You are in room 2.
Exits go to: 1, 10, 3
-----------------------------------------
What do you want to do? (m)ove or (s)hoot? m
Where? 10
-----------------------------------------
You are in room 10.
Exits go to: 2, 11, 9
</code></pre>

<p>Even after only a couple actions, the player can start to piece together
a map of the cave’s topography, which will help them avoid getting lost
as they continue their explorations:</p>

<p><img src="//i.imgur.com/5gCTOAt.png" alt="" /></p>

<p>Play continues in this fashion, with the player wandering around until 
a hazard is detected:</p>

<pre><code>What do you want to do? (m)ove or (s)hoot? m
Where? 11
-----------------------------------------
You are in room 11.
Exits go to: 10, 8, 20
-----------------------------------------
What do you want to do? (m)ove or (s)hoot? m
Where? 20
-----------------------------------------
You are in room 20.
You feel a cold wind blowing from a nearby cavern.
Exits go to: 11, 19, 17
</code></pre>

<p>In this case, the player has managed to get close
to a bottomless pit, which is detected by the presence of
a cold wind emanating from an adjacent room.</p>

<p>Because hazards are sensed indirectly, the player needs to use a deduction
process to know for sure which hazards are in what rooms. With the knowledge of
the cave layout so far, the only thing that is for certain is there is at least one
pit nearby, with both rooms 17 and 19 being possible candidates. One of them
might be safe, but there is also a chance that BOTH rooms contain pits.
In a literal sense, the player might have reached a dead end:</p>

<p><img src="//i.imgur.com/D6aA2wl.png" alt="" /></p>

<p>A risky player might chance it and try one of the two rooms, but
that isn’t a smart way to play. The safe option is to 
backtrack in search of a different path through the cave:</p>

<pre><code>What do you want to do? (m)ove or (s)hoot? m
Where? 11
-----------------------------------------
You are in room 11.
Exits go to: 10, 8, 20
-----------------------------------------
What do you want to do? (m)ove or (s)hoot? m
Where? 8
-----------------------------------------
You are in room 8.
You smell something terrible nearby
Exits go to: 11, 1, 7
</code></pre>

<p>Changing directions ends up paying off. Upon entering room 8,
the terrible smell that is sensed indicates that the Wumpus is nearby,
and because rooms 1 and 11 have already been visited, there
is only one place left for the Wumpus to be hiding:</p>

<pre><code>What do you want to do? (m)ove or (s)hoot? s
Where? 7
-----------------------------------------
YOU KILLED THE WUMPUS! GOOD JOB, BUDDY!!!
</code></pre>

<p>At the end of the hunt, the player’s map ended up looking like this:</p>

<p><img src="//i.imgur.com/IZnqNNw.png" alt="" /></p>

<p>In less fortunate circumstances, the player would need to do a lot more
exploration before they could be certain about where the Wumpus 
was hiding. Other hazards might also be encountered, including giant bats 
that are capable of moving the player to a random location in the cave.
Because all these factors are randomized in each new game, Hunt the Wumpus
can be played again and again without ever encountering an identical
cave layout.</p>

<p>We will discuss more about the game rules throughout the rest of this
article, but the few concepts illustrated in this demonstration are more 
than enough for us to start modeling some of the key game objects.
Let’s get to work!</p>

<h2 id="implementing-hunt-the-wumpus-from-scratch">Implementing “Hunt the Wumpus” from scratch</h2>

<p>Like many programs from its era, Hunt the Wumpus was designed to 
be hackable. If you look at one of the <a href="http://www.atariarchives.org/bcc1/showpage.php?page=247">original publications</a>
about the game, you can see that the author actively encourages
tweaking its rules, and even includes the full source code 
of the game.</p>

<p>Before you rush off to study the original implementation, remember that 
it was written four decades ago in BASIC. Unless you consider yourself
a technological archaeologist, it’s probably not the best way to
learn about the game. With that in mind, I’ve put together a learning
exercise that will guide you through implementing some of the core 
game concepts of Hunt the Wumpus – without getting bogged down in
specific game rules or having to write boring user interface code.</p>

<p>In particular, I want you to implement three classes that I have 
already written the tests for:</p>

<ol>
  <li>A <code>Wumpus::Room</code> class to manage hazards and connections between rooms</li>
  <li>A <code>Wumpus::Cave</code> class to manage the overall topography of the cave</li>
  <li>A <code>Wumpus::Player</code> class that handles sensing and encountering hazards</li>
</ol>

<p>You can work through this exercise by <a href="https://github.com/elm-city-craftworks/wumpus">cloning its git repository</a>, 
and following the instructions in the README. I have put the tests for each 
class on its own branch, so that you can merge them into your own code 
one at a time until you end up with a complete passing test suite.</p>

<p>Once these three classes are written, you’ll be able to use my UI code 
and game logic to play a rousing round of Hunt the Wumpus. You’ll
also be able to compare your own work to my <a href="https://github.com/elm-city-craftworks/wumpus/tree/reference_implementation">reference implementation</a>
of the game, and discuss any questions or thoughts with me about
the differences between our approaches.</p>

<p>Throughout the rest of this article, I will provide design and implementation
notes for each class, as well as a brief overview of how the game rules for
Hunt the Wumpus can be implemented using these objects. These notes
should help you interpret what the test suite is actually asking
you to build, and will also help you understand my reference
implementation.</p>

<blockquote>
  <p><strong>NOTE:</strong> If you’re short on time or aren’t in the mood for hacking
right now, you can still get a lot out of this exercise by simply 
thinking about how you’d write the code to pass the provided test 
suite, and then looking my implementation. But it’s definitely
better to at least <em>try</em> to write some code yourself, even
if you don’t complete the full exercise.</p>
</blockquote>

<h2 id="modeling-rooms">Modeling rooms</h2>

<p>Structurally speaking, rooms and their connections form a simple undirected graph:</p>

<p><img src="//i.imgur.com/p81T0Gn.png" alt="" /></p>

<p>Our <code>Room</code> class will manage these connections, and also make it easy 
to query and manipulate the hazards that can be found in a room –
including bats, pits, and the wumpus itself. In particular, we will
build an object with the following attributes and behaviors:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>describe <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">A room</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">do</span>
  it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">has a number</span><span style="color:#710">&quot;</span></span>
  it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">may contain hazards</span><span style="color:#710">&quot;</span></span>

  describe <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">with neighbors</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">do</span>
    it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">has two-way connections to neighbors</span><span style="color:#710">&quot;</span></span>
    it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">knows the numbers of all neighboring rooms</span><span style="color:#710">&quot;</span></span>
    it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">can choose a neighbor randomly</span><span style="color:#710">&quot;</span></span>
    it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">is not safe if it has hazards</span><span style="color:#710">&quot;</span></span> 
    it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">is not safe if its neighbors have hazards</span><span style="color:#710">&quot;</span></span>
    it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">is safe when it and its neighbors have no hazards</span><span style="color:#710">&quot;</span></span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>Let’s walk through each of these requirements individually and fill
in the necessary details.</p>

<p>1) Every room has an identifying number that helps the player keep 
track of where they are:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>describe <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">A room</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">do</span>
  let(<span style="color:#A60">:room</span>) { <span style="color:#036;font-weight:bold">Wumpus</span>::<span style="color:#036;font-weight:bold">Room</span>.new(<span style="color:#00D">12</span>) }

  it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">has a number</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">do</span>
    room.number.must_equal(<span style="color:#00D">12</span>)
  <span style="color:#080;font-weight:bold">end</span>

  <span style="color:#777"># ...</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>2) Rooms may contain hazards, which can be added or removed as the 
game progresses:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">may contain hazards</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">do</span> 
  <span style="color:#777"># rooms start out empty</span>
  assert room.empty?

  <span style="color:#777"># hazards can be added</span>
  room.add(<span style="color:#A60">:wumpus</span>)
  room.add(<span style="color:#A60">:bats</span>)

  <span style="color:#777"># a room with hazards isn't empty</span>
  refute room.empty?

  <span style="color:#777"># hazards can be detected by name</span>
  assert room.has?(<span style="color:#A60">:wumpus</span>)
  assert room.has?(<span style="color:#A60">:bats</span>)

  refute room.has?(<span style="color:#A60">:alf</span>)

  <span style="color:#777"># hazards can be removed</span>
  room.remove(<span style="color:#A60">:bats</span>)
  refute room.has?(<span style="color:#A60">:bats</span>)
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>3) Each room can be connected to other rooms in the cave:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>describe <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">with neighbors</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">do</span>
  let(<span style="color:#A60">:exit_numbers</span>) { [<span style="color:#00D">11</span>, <span style="color:#00D">3</span>, <span style="color:#00D">7</span>] }

  before <span style="color:#080;font-weight:bold">do</span>
    exit_numbers.each { |i| room.connect(<span style="color:#036;font-weight:bold">Wumpus</span>::<span style="color:#036;font-weight:bold">Room</span>.new(i)) }
  <span style="color:#080;font-weight:bold">end</span>

   <span style="color:#777"># ...</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>4) One-way paths are not allowed, i.e. all connections between rooms are
bidirectional:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">has two-way connections to neighbors</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">do</span>
  exit_numbers.each <span style="color:#080;font-weight:bold">do</span> |i| 
    <span style="color:#777"># a neighbor can be looked up by room number</span>
    room.neighbor(i).number.must_equal(i)

    <span style="color:#777"># Room connections are bidirectional</span>
    room.neighbor(i).neighbor(room.number).must_equal(room)
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>5) Each room knows all of its exits, which consist of
all neighboring room numbers:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">knows the numbers of all neighboring rooms</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">do</span>
  room.exits.must_equal(exit_numbers)
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>6) Neighboring rooms can be selected at random, which is
useful for certain game events:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">can choose a neighbor randomly</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">do</span>
  exit_numbers.must_include(room.random_neighbor.number)
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>7) A room is considered safe only if there are no hazards within it
or any of its neighbors:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">is not safe if it has hazards</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">do</span>
  room.add(<span style="color:#A60">:wumpus</span>)

  refute room.safe?
<span style="color:#080;font-weight:bold">end</span>

it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">is not safe if its neighbors have hazards</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">do</span>
  room.random_neighbor.add(<span style="color:#A60">:wumpus</span>)

  refute room.safe?
<span style="color:#080;font-weight:bold">end</span>

it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">is safe when it and its neighbors have no hazards</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">do</span>
  assert room.safe?
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p><strong>Implementation notes</strong></p>

<p>Because this object only handles basic data tranformations, it
shouldn’t be hard to implement. But if you get stuck, you
can always look at <a href="https://github.com/elm-city-craftworks/wumpus/blob/reference_implementation/lib/wumpus/room.rb">my version of the Wumpus::Room class</a>.</p>

<h2 id="modeling-the-cave">Modeling the cave</h2>

<p>Although a game of Hunt the Wumpus can be played with an arbitrary cave layout,
the traditional Wumpus cave is based on the <a href="http://en.wikipedia.org/wiki/Dodecahedron">dodecahedron</a>. To
model things this way, a room is placed at each vertex, and the edges form
the connections between rooms. If you squash the structure to fit in a
two-dimensional space, you end up with the following graph:</p>

<p><img src="//i.imgur.com/Myxk4vS.png" alt="" /></p>

<p>Even though it would be technically possible to construct this structure without
a collection object by connecting rooms together in an ad-hoc fashion,
traversing the structure and manipulating it would be cumbersome. For that
reason, we will build a <code>Wumpus::Cave</code> object with the following properties:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>describe <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">A cave</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">do</span>
  it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">has 20 rooms that each connect to exactly three other rooms</span><span style="color:#710">&quot;</span></span> 
  it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">can select rooms at random</span><span style="color:#710">&quot;</span></span>
  it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">can move hazards from one room to another</span><span style="color:#710">&quot;</span></span>
  it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">can add hazards at random to a specific number of rooms</span><span style="color:#710">&quot;</span></span>
  it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">can find a room with a particular hazard</span><span style="color:#710">&quot;</span></span>
  it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">can find a safe room to serve as an entrance</span><span style="color:#710">&quot;</span></span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>Some of these features a bit tricky to explain comprehensively through
tests, but the following examples should give you a basic idea of
how they’re meant to work.</p>

<p>1) The cave has 20 rooms, and each room is connected to exactly 
three other rooms:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>describe <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">A cave</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">do</span>
  let(<span style="color:#A60">:cave</span>)  { <span style="color:#036;font-weight:bold">Wumpus</span>::<span style="color:#036;font-weight:bold">Cave</span>.dodecahedron }
  let(<span style="color:#A60">:rooms</span>) { (<span style="color:#00D">1</span>..<span style="color:#00D">20</span>).map { |i| cave.room(i) } }

  it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">has 20 rooms that each connect to exactly three other rooms</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">do</span>
    rooms.each <span style="color:#080;font-weight:bold">do</span> |room|
      room.neighbors.count.must_equal(<span style="color:#00D">3</span>)
      
      assert room.neighbors.all? { |e| e.neighbors.include?(room) }
    <span style="color:#080;font-weight:bold">end</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>The intent here is to loosly verify that the layout is dodecahedron 
shaped, but it is more of a sanity check than a strict validation.
A stronger check would require us to compute things like minimal
cycles for each point, which would make for a much more 
complicated test.</p>

<p>In my implementation I use a JSON file that hard-codes the 
connections between each room explicitly rather than trying to 
automatically generate the layout, so this test is mostly just to catch errors 
with that configuration file. If you reuse the <a href="https://raw.github.com/elm-city-craftworks/wumpus/reference_implementation/data/dodecahedron.json">dodecahredon.json</a> 
file in your own code, it should make passing these tests easy.</p>

<p>2) Rooms in the cave can be selected randomly:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">can select rooms at random</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">do</span>
  sampling = <span style="color:#036;font-weight:bold">Set</span>.new

  <span style="color:#777"># see test/helper.rb for how this assertion works</span>
  must_eventually(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">randomly select each room</span><span style="color:#710">&quot;</span></span>) <span style="color:#080;font-weight:bold">do</span>
    new_room = cave.random_room 
    sampling &lt;&lt; new_room

    sampling == <span style="color:#036;font-weight:bold">Set</span>[*rooms] 
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>This feature is important for implementing the behavior of giant bats, who move
the player to a random location in the cave. It is also useful for hazard
placement, as we’ll see later. The way I test the behavior is a bit awkward,
but the basic idea is that if you keep selecting rooms at random, you’ll
eventually hit every room in the cave.</p>

<p>3) Hazards can be moved from one room to another:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">can move hazards from one room to another</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">do</span>
  room      = cave.random_room
  neighbor  = room.neighbors.first

  room.add(<span style="color:#A60">:bats</span>)

  assert room.has?(<span style="color:#A60">:bats</span>)
  refute neighbor.has?(<span style="color:#A60">:bats</span>)

  cave.move(<span style="color:#A60">:bats</span>, <span style="color:#A60">:from</span> =&gt; room, <span style="color:#A60">:to</span> =&gt; neighbor)

  refute room.has?(<span style="color:#A60">:bats</span>)
  assert neighbor.has?(<span style="color:#A60">:bats</span>)
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>This test shows bats being moved from a random room to
one of its neighbors, but <code>Cave#move</code> can used to move any hazard
between any two rooms in the cave, even if they are not
adajecent to each other.</p>

<p>4) Hazards can be randomly distributed throughout the cave:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">can add hazards at random to a specific number of rooms</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">do</span>
  cave.add_hazard(<span style="color:#A60">:bats</span>, <span style="color:#00D">3</span>)

  rooms.select { |e| e.has?(<span style="color:#A60">:bats</span>) }.count.must_equal(<span style="color:#00D">3</span>)
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>For the most part, the work to be done here is just to pick
some rooms at random and add hazards
to them. However, because there is no sense in adding a single
type of hazard to a room more than once, <code>Cave#add_hazard</code>
should take care to select only rooms that do not already have
the specified hazard in them. This is hinted at by the specs,
but because the check is a loose one, just keep this detail
in mind while implementing this method.</p>

<p>5) Rooms can be looked up based on the hazards they contain:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">can find a room with a particular hazard</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">do</span>
  cave.add_hazard(<span style="color:#A60">:wumpus</span>, <span style="color:#00D">1</span>)

  assert cave.room_with(<span style="color:#A60">:wumpus</span>).has?(<span style="color:#A60">:wumpus</span>)
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>In my implementation, I just grab the first room that matches the 
criteria, but any matching room would be acceptable. It
would also make sense to have a <code>Cave#all_rooms_with</code> method, but it isn’t needed for a basic implementation
of the game.</p>

<p>6) A safe entrance can be located:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">can find a safe room to serve as an entrance</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">do</span>
  cave.add_hazard(<span style="color:#A60">:wumpus</span>, <span style="color:#00D">1</span>)
  cave.add_hazard(<span style="color:#A60">:pit</span>, <span style="color:#00D">3</span>)
  cave.add_hazard(<span style="color:#A60">:bats</span>, <span style="color:#00D">3</span>)

  entrance = cave.entrance

  assert entrance.safe?
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>This is where the <code>Wumpus::Room#safe?</code> method comes in handy. Picking any room
that passes that condition is enough to get the job done here.</p>

<p><strong>Implementation notes</strong></p>

<p>The desired behavior of the <code>Wumpus::Cave</code> class is admittedly a bit
underspecified here, but in many cases minor variations won’t effect
gameplay all that much. Some of these operations are also intentionally 
a bit more general than what is strictly needed for the game, to permit 
some experimentation with rule changes once you have a working implementation. </p>

<p>This was a challenging object for me to design and test, because many 
of the features which are intuitively obvious are hard to specify 
formally. Do the best you can with building it, and refer
to <a href="https://github.com/elm-city-craftworks/wumpus/blob/reference_implementation/lib/wumpus/cave.rb">my implementation of the Wumpus::Cave class</a> whenever 
you hit any snags.</p>

<h2 id="modeling-the-player">Modeling the player</h2>

<p>Despite the complexity of the cave layout, most game events in 
Hunt the Wumpus are triggered by local conditions based on the 
player’s current room and its direct neighbors. For example, 
imagine that the player is positioned in Room #1 as shown in 
following diagram:</p>

<p><img src="//i.imgur.com/A0e5pMn.png" alt="" /></p>

<p>With this setup, the player would sense the nearby hazards,
resulting in the following output:</p>

<pre><code>You are in room 1.
You hear a rustling sound nearby
You smell something terrible nearby
Exits go to: 2, 3, 4
</code></pre>

<p>Ordinarily we’d need to do some investigation work to discover which hazards
were where, but because this is a contrived scenario, we don’t 
need to guess. Knowing the layout of the neighborhood, we can enumerate the 
possible outcomes for any player action:</p>

<ul>
  <li>The player will encounter the wumpus upon moving into room 2.</li>
  <li>The player will encounter bats upon moving into room 3.</li>
  <li>The player will not encounter any hazards in room 4.</li>
  <li>The player can shoot into room 2 to kill the wumpus.</li>
  <li>The player will miss the wumpus by shooting into room 3 or 4.</li>
</ul>

<p>If you take this single example and generalize it, you’ll find that every turn
of Hunt the Wumpus involves only three distinct kinds of events:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>describe <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">the player</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">do</span>
  it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">can sense hazards in neighboring rooms</span><span style="color:#710">&quot;</span></span> 
  it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">can encounter hazards when entering a room</span><span style="color:#710">&quot;</span></span>
  it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">can perform actions on neighboring rooms</span><span style="color:#710">&quot;</span></span> 
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>With these requirements in mind, it is possible for us to model 
the <code>Wumpus::Player</code> class as an event-driven object that handles 
each event type listed above. The only state it needs to explicitly
maintain is a reference to the room currently being explored: everything 
else can be managed externally through callbacks. You’ll see why this
is useful when we look at how the game rules are implemented later,
but for now just try to follow along as best as you can.</p>

<p>The test setup for the <code>Wumpus::Player</code> class is a bit complicated, mostly 
because we need to reconstruct something similar to the layout shown in the
previous diagram in order to meaningfully test its behavior:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>describe <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">the player</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">do</span>
  let(<span style="color:#A60">:player</span>) { <span style="color:#036;font-weight:bold">Wumpus</span>::<span style="color:#036;font-weight:bold">Player</span>.new }

  let(<span style="color:#A60">:empty_room</span>) { <span style="color:#036;font-weight:bold">Wumpus</span>::<span style="color:#036;font-weight:bold">Room</span>.new(<span style="color:#00D">1</span>) }

  let(<span style="color:#A60">:wumpus_room</span>) <span style="color:#080;font-weight:bold">do</span>
    <span style="color:#036;font-weight:bold">Wumpus</span>::<span style="color:#036;font-weight:bold">Room</span>.new(<span style="color:#00D">2</span>).tap { |e| e.add(<span style="color:#A60">:wumpus</span>) }
  <span style="color:#080;font-weight:bold">end</span>

  let(<span style="color:#A60">:bat_room</span>) <span style="color:#080;font-weight:bold">do</span>
    <span style="color:#036;font-weight:bold">Wumpus</span>::<span style="color:#036;font-weight:bold">Room</span>.new(<span style="color:#00D">3</span>).tap { |e| e.add(<span style="color:#A60">:bats</span>) }
  <span style="color:#080;font-weight:bold">end</span>

  <span style="color:#777"># ...</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>In addition to wiring up some rooms, I also register all of the events we’re 
interested in tracking during setup, using some dummy callbacks that are
meant to serve as stand-ins for real game logic. This is not an
elegant way of building a test harness, but it gets the job done:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>let(<span style="color:#A60">:sensed</span>)      { <span style="color:#036;font-weight:bold">Set</span>.new }
let(<span style="color:#A60">:encountered</span>) { <span style="color:#036;font-weight:bold">Set</span>.new }

before <span style="color:#080;font-weight:bold">do</span>
  empty_room.connect(bat_room)
  empty_room.connect(wumpus_room)

  player.sense(<span style="color:#A60">:bats</span>) <span style="color:#080;font-weight:bold">do</span>
    sensed &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">You hear a rustling</span><span style="color:#710">&quot;</span></span>
  <span style="color:#080;font-weight:bold">end</span>

  player.sense(<span style="color:#A60">:wumpus</span>) <span style="color:#080;font-weight:bold">do</span>
    sensed &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">You smell something terrible</span><span style="color:#710">&quot;</span></span>
  <span style="color:#080;font-weight:bold">end</span>

  player.encounter(<span style="color:#A60">:wumpus</span>) <span style="color:#080;font-weight:bold">do</span>
    encountered &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">The wumpus ate you up!</span><span style="color:#710">&quot;</span></span>
  <span style="color:#080;font-weight:bold">end</span>

  player.encounter(<span style="color:#A60">:bats</span>) <span style="color:#080;font-weight:bold">do</span>
    encountered &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">The bats whisk you away!</span><span style="color:#710">&quot;</span></span>
  <span style="color:#080;font-weight:bold">end</span>

  player.action(<span style="color:#A60">:move</span>) <span style="color:#080;font-weight:bold">do</span> |destination|
    player.enter(destination)
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>Once all of that is taken care of, the callbacks can be tested in isolated
scenarios:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">can sense hazards in neighboring rooms</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">do</span>
  player.enter(empty_room)
  player.explore_room

  sensed.must_equal(<span style="color:#036;font-weight:bold">Set</span>[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">You hear a rustling</span><span style="color:#710">&quot;</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">You smell something terrible</span><span style="color:#710">&quot;</span></span>])
  
  assert encountered.empty?
<span style="color:#080;font-weight:bold">end</span>

it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">can encounter hazards when entering a room</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">do</span>
  player.enter(bat_room)
  encountered.must_equal(<span style="color:#036;font-weight:bold">Set</span>[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">The bats whisk you away!</span><span style="color:#710">&quot;</span></span>])
  
  assert sensed.empty? 
<span style="color:#080;font-weight:bold">end</span>

it <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">can perform actions on neighboring rooms</span><span style="color:#710">&quot;</span></span> <span style="color:#080;font-weight:bold">do</span>
  player.act(<span style="color:#A60">:move</span>, wumpus_room)
  player.room.must_equal(wumpus_room)

  encountered.must_equal(<span style="color:#036;font-weight:bold">Set</span>[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">The wumpus ate you up!</span><span style="color:#710">&quot;</span></span>])
  assert sensed.empty?
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>These test cases verify that the right callbacks have been called
by manipulating simple sets of strings, but the real use case for 
the <code>Wumpus::Player</code> class is to trigger  operations on 
game objects as well as the user interface. If you are having
trouble imagining what that would look like, it may help to 
read ahead a bit further before attempting to get these 
tests to pass.</p>

<p><strong>Implementation notes:</strong></p>

<p>Like the <code>Wumpus::Cave</code> class, this object is underspecified, but you probably
don’t need to build something identical to <a href="https://github.com/elm-city-craftworks/wumpus/blob/reference_implementation/lib/wumpus/player.rb">my implementation of Wumpus::Player</a>
in order to get the game to run. However, you may want to make an effort
to ensure that callbacks are triggered in the order that they are registered,
otherwise you can run into some interesting edge cases when more than one
condition is satisfied at the same time.</p>

<h2 id="defining-the-game-rules">Defining the game rules</h2>

<p>With a foundation in place, implementing the game logic for Hunt the
Wumpus is very easy. My version of the game simplifies the rules, but
hopefully still captures the spirit of the original.  </p>

<p>As you walk through the following code, you can treat the
<code>Wumpus::Narrator</code> object as a black box. This is a boring object that
only does some basic I/O under the hood, so your time
would be better spent focusing on the game logic.</p>

<p>With that caveat out of the way, let’s take a look at how Hunt the Wumpus can be
implemented in terms of the three game objects we just built. To get started, we
need a cave!</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>cave = <span style="color:#036;font-weight:bold">Wumpus</span>::<span style="color:#036;font-weight:bold">Cave</span>.dodecahedron
</pre></div>
</div>
</div>

<p>This cave will contain three pits, three giant bats, and the most evil and
stinky Wumpus you could ever imagine:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>cave.add_hazard(<span style="color:#A60">:wumpus</span>, <span style="color:#00D">1</span>)
cave.add_hazard(<span style="color:#A60">:pit</span>, <span style="color:#00D">3</span>)
cave.add_hazard(<span style="color:#A60">:bats</span>, <span style="color:#00D">3</span>)
</pre></div>
</div>
</div>

<p>We also need a player to navigate the cave, and a narrator to regale us with
tales about the player’s adventures:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>player    = <span style="color:#036;font-weight:bold">Wumpus</span>::<span style="color:#036;font-weight:bold">Player</span>.new
narrator  = <span style="color:#036;font-weight:bold">Wumpus</span>::<span style="color:#036;font-weight:bold">Narrator</span>.new
</pre></div>
</div>
</div>

<p>Whenever a player senses a hazard nearby, the narrator will give us a hint
of what kind of trouble lurks just around the bend:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>player.sense(<span style="color:#A60">:bats</span>) <span style="color:#080;font-weight:bold">do</span>
  narrator.say(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">You hear a rustling sound nearby</span><span style="color:#710">&quot;</span></span>) 
<span style="color:#080;font-weight:bold">end</span>

player.sense(<span style="color:#A60">:wumpus</span>) <span style="color:#080;font-weight:bold">do</span>
  narrator.say(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">You smell something terrible nearby</span><span style="color:#710">&quot;</span></span>)
<span style="color:#080;font-weight:bold">end</span>

player.sense(<span style="color:#A60">:pit</span>) <span style="color:#080;font-weight:bold">do</span>
  narrator.say(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">You feel a cold wind blowing from a nearby cavern.</span><span style="color:#710">&quot;</span></span>)
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>If upon entering a room the player encounters the Wumpus, it
will become startled. We’ll discuss the detailed consequences
of this later, but the basic idea is that it will cause the
Wumpus to either run away to an adjacent room, or to gobble
the player up:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>player.encounter(<span style="color:#A60">:wumpus</span>) <span style="color:#080;font-weight:bold">do</span>
  player.act(<span style="color:#A60">:startle_wumpus</span>, player.room)
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>When bats are encountered, the narrator will inform us of
the event, then a random room will be selected to drop
the player off in. If any hazards are encountered
in that room, the effects will be applied immediately,
possibly leading to the player’s demise.</p>

<p>But assuming that the player managed to survive the flight, 
the bats will take up residence in the new location. This
can make navigation very complicated, because stumbling
back into that room will cause the player to be moved
to yet another random location:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>player.encounter(<span style="color:#A60">:bats</span>) <span style="color:#080;font-weight:bold">do</span>
  narrator.say <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Giant bats whisk you away to a new cavern!</span><span style="color:#710">&quot;</span></span>

  old_room = player.room
  new_room = cave.random_room

  player.enter(new_room)

  cave.move(<span style="color:#A60">:bats</span>, <span style="color:#606">from</span>: old_room, <span style="color:#606">to</span>: new_room)
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>If the player happens to come across a bottomless pit, the
story ends immediately, even though the player’s journey
will probably go on forever:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>player.encounter(<span style="color:#A60">:pit</span>) <span style="color:#080;font-weight:bold">do</span>
  narrator.finish_story(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">You fell into a bottomless pit. Enjoy the ride!</span><span style="color:#710">&quot;</span></span>)
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>The player’s actions are what ultimately ends up triggering game events. 
The movement action is straightforward: it simply updates the player’s
current location and then fires callbacks for any hazards encountered:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>player.action(<span style="color:#A60">:move</span>) <span style="color:#080;font-weight:bold">do</span> |destination|
  player.enter(destination)
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>Shooting is more complicated, although the way it is implemented here
is still a simplification of how the original game worked. In Gregory Yob’s
version, you had only five arrows, but they could travel a distance of up to
five rooms, even shooting around corners if you knew the right path. In my
version, arrows are unlimited but can only fire into neighboring rooms.</p>

<p>If the player shoots into the room that the Wumpus is hiding in, the beast 
is slayed and the story ends happily ever after. If instead the player shoots
into the wrong room, then no matter where the Wumpus is in the cave, it will 
be startled by the sound.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>player.action(<span style="color:#A60">:shoot</span>) <span style="color:#080;font-weight:bold">do</span> |destination|
  <span style="color:#080;font-weight:bold">if</span> destination.has?(<span style="color:#A60">:wumpus</span>)
    narrator.finish_story(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">YOU KILLED THE WUMPUS! GOOD JOB, BUDDY!!!</span><span style="color:#710">&quot;</span></span>) 
  <span style="color:#080;font-weight:bold">else</span>
    narrator.say(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Your arrow missed!</span><span style="color:#710">&quot;</span></span>)

    player.act(<span style="color:#A60">:startle_wumpus</span>, cave.room_with(<span style="color:#A60">:wumpus</span>))
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>When the Wumpus is startled, it will either stay where it is or move into
one of its neighboring rooms. The player will be able to hear the Wumpus
move anywhere in the cave, even if it is not in a nearby room.</p>

<p>If the Wumpus is in the same room as the player at the end of this process,
it will gobble the player up and the game will end in sadness and tears:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>player.action(<span style="color:#A60">:startle_wumpus</span>) <span style="color:#080;font-weight:bold">do</span> |old_wumpus_room|
  <span style="color:#080;font-weight:bold">if</span> [<span style="color:#A60">:move</span>, <span style="color:#A60">:stay</span>].sample == <span style="color:#A60">:move</span>
    new_wumpus_room = old_wumpus_room.random_neighbor
    cave.move(<span style="color:#A60">:wumpus</span>, <span style="color:#606">from</span>: old_wumpus_room, <span style="color:#606">to</span>: new_wumpus_room)

    narrator.say(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">You heard a rumbling in a nearby cavern.</span><span style="color:#710">&quot;</span></span>)
  <span style="color:#080;font-weight:bold">end</span>

  <span style="color:#080;font-weight:bold">if</span> player.room.has?(<span style="color:#A60">:wumpus</span>)
    narrator.finish_story(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">You woke up the wumpus and he ate you!</span><span style="color:#710">&quot;</span></span>)
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>And that pretty much sums it up. I omitted a few lines of boilerplate
code that fire up the main event loop, but this pretty much covers
all of the code that implements the actual game rules. It is designed
to be very hackable, so please do experiment with it however you’d like.</p>

<p>If you want to review the full game executable without the intermingled
commentary, please see <a href="https://github.com/elm-city-craftworks/wumpus/blob/reference_implementation/bin/wumpus">the bin/wumpus script</a>.</p>

<h2 id="additional-exercises">Additional Exercises</h2>

<p>Hopefully by working through this article you’ve seen for yourself why Hunt the
Wumpus is both fun to play and fun to implement. If you are looking for more
things to try, I’d suggest the following activities:</p>

<ul>
  <li>
    <p>Limit the number of arrows that the player can shoot, and end the game when
the player runs out of arrows.</p>
  </li>
  <li>
    <p>Try implementing the “crooked arrow” behavior of the original Wumpus game. To
do this allow the player to specify a path of up to five rooms. Whenever the
player guesses an incorrect path, have the arrow to bounce into a random room.
If the arrow ends up hitting the player because of this, they lose!</p>
  </li>
  <li>
    <p>Make it harder to guess the connections between rooms by randomizing
the room numbers for each new game while keeping the overall shape the same.</p>
  </li>
  <li>
    <p>Try out one of the alternative cave layouts described in Gregory Yob’s
followup publication about <a href="http://www.atariarchives.org/bcc2/showpage.php?page=244">Wumpus 2</a>.</p>
  </li>
  <li>
    <p>Add new hazards of your own, or other types of game objects that
are beneficial, or provide some more depth to the story.</p>
  </li>
  <li>
    <p>Implement a solver bot that plays the game automatically.</p>
  </li>
  <li>
    <p>Build a better user interface for the game, either improving the text-based
UI or attempting something using a GUI or web-based interface. You should
only need to edit the <code>Wumpus::Narrator</code> and <code>Wumpus::Console</code> objects
in order to replace the current interface.</p>
  </li>
  <li>
    <p>Keep the game behavior the same, but try out a different design than the one
I provided here and/or improve the test suite.</p>
  </li>
</ul>

<p>If you try out any of these extra credit exercises, please share your work. I’d
be very interested to see what you come up with. Until then, happy hacking!</p>


  </div>
</body>
</html>

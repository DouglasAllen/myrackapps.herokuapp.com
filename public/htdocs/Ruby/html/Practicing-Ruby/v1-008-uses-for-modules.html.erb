<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/>
  <title>Practicing Ruby</title>
  <style>
    body {
      font-family: "Helvetica Neue", arial, sans-serif;
      font-size: 14px;
      line-height: 1.6;
      padding-top: 10px;
      padding-bottom: 10px;
      background-color: white;
      padding: 30px;
      color: #333;
      border: 1px solid #aaa;
      max-width: 900px;
      margin: 20px auto;
    }

    body > *:first-child {
      margin-top: 0 !important;
    }

    body > *:last-child {
      margin-bottom: 0 !important;
    }

    a {
      color: #4183C4;
      text-decoration: none;
    }

    a.absent {
      color: #cc0000;
    }

    a.anchor {
      display: block;
      padding-left: 30px;
      margin-left: -30px;
      cursor: pointer;
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
    }

    h1, h2, h3, h4, h5, h6 {
      margin: 20px 0 10px;
      padding: 0;
      font-weight: bold;
      -webkit-font-smoothing: antialiased;
      cursor: text;
      position: relative;
    }

    h2:first-child, h1:first-child, h1:first-child + h2, h3:first-child, h4:first-child, h5:first-child, h6:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
      text-decoration: none;
    }

    h1 tt, h1 code {
      font-size: inherit;
    }

    h2 tt, h2 code {
      font-size: inherit;
    }

    h3 tt, h3 code {
      font-size: inherit;
    }

    h4 tt, h4 code {
      font-size: inherit;
    }

    h5 tt, h5 code {
      font-size: inherit;
    }

    h6 tt, h6 code {
      font-size: inherit;
    }

    h1 {
      font-size: 28px;
      color: black;
    }

    h2 {
      font-size: 24px;
      border-bottom: 1px solid #cccccc;
      color: black;
    }

    h3 {
      font-size: 18px;
    }

    h4 {
      font-size: 16px;
    }

    h5 {
      font-size: 14px;
    }

    h6 {
      color: #777777;
      font-size: 14px;
    }

    p, blockquote, ul, ol, dl, li, table, pre {
      margin: 3px 0;
    }

    hr {
      background: transparent url("http://tinyurl.com/bq5kskr") repeat-x 0 0;
      border: 0 none;
      color: #cccccc;
      height: 4px;
      padding: 0;
    }

    body > h2:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    body > h1:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    body > h1:first-child + h2 {
      margin-top: 0;
      padding-top: 0;
    }

    body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
      margin-top: 0;
      padding-top: 0;
    }

    h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
      margin-top: 0;
    }

    li p.first {
      display: inline-block;
    }

    ul, ol {
      padding-left: 30px;
    }

    ul :first-child, ol :first-child {
      margin-top: 0;
    }

    ul :last-child, ol :last-child {
      margin-bottom: 0;
    }

    dl {
      padding: 0;
    }

    dl dt {
      font-size: 14px;
      font-weight: bold;
      font-style: italic;
      padding: 0;
      margin: 15px 0 5px;
    }

    dl dt:first-child {
      padding: 0;
    }

    dl dt > :first-child {
      margin-top: 0;
    }

    dl dt > :last-child {
      margin-bottom: 0;
    }

    dl dd {
      margin: 0 0 15px;
      padding: 0 15px;
    }

    dl dd > :first-child {
      margin-top: 0;
    }

    dl dd > :last-child {
      margin-bottom: 0;
    }

    blockquote {
      border-left: 4px solid #dddddd;
      padding: 0 15px;
      color: #777777;
    }

    blockquote > :first-child {
      margin-top: 0;
    }

    blockquote > :last-child {
      margin-bottom: 0;
    }

    table {
      padding: 0;
    }
    table tr {
      border-top: 1px solid #cccccc;
      background-color: white;
      margin: 0;
      padding: 0;
    }

    table tr:nth-child(2n) {
      background-color: #f8f8f8;
    }

    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      text-align: left;
      margin: 0;
      padding: 6px 13px;
    }

    table tr td {
      border: 1px solid #cccccc;
      text-align: left;
      margin: 0;
      padding: 6px 13px;
    }

    table tr th :first-child, table tr td :first-child {
      margin-top: 0;
    }

    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0;
    }

    img {
      max-width: 100%;
    }

    span.frame {
      display: block;
      overflow: hidden;
    }

    span.frame > span {
      border: 1px solid #dddddd;
      display: block;
      float: left;
      overflow: hidden;
      margin: 13px 0 0;
      padding: 7px;
      width: auto;
    }

    span.frame span img {
      display: block;
      float: left;
    }

    span.frame span span {
      clear: both;
      color: #333333;
      display: block;
      padding: 5px 0 0;
    }

    span.align-center {
      display: block;
      overflow: hidden;
      clear: both;
    }

    span.align-center > span {
      display: block;
      overflow: hidden;
      margin: 13px auto 0;
      text-align: center;
    }

    span.align-center span img {
      margin: 0 auto;
      text-align: center;
    }

    span.align-right {
      display: block;
      overflow: hidden;
      clear: both;
    }

    span.align-right > span {
      display: block;
      overflow: hidden;
      margin: 13px 0 0;
      text-align: right;
    }

    span.align-right span img {
      margin: 0;
      text-align: right;
    }

    span.float-left {
      display: block;
      margin-right: 13px;
      overflow: hidden;
      float: left;
    }

    span.float-left span {
      margin: 13px 0 0;
    }

    span.float-right {
      display: block;
      margin-left: 13px;
      overflow: hidden;
      float: right;
    }

    span.float-right > span {
      display: block;
      overflow: hidden;
      margin: 13px auto 0;
      text-align: right;
    }

    code, tt {
      font-family: "Lucida Console", "Courier New", courier;
      font-size: 12px;
      margin: 0 2px;
      padding: 3px 5px;
      white-space: nowrap;
      border: 1px solid #eaeaea;
      background-color: #f8f8f8;
      border-radius: 3px;
    }

    pre code {
      margin: 0;
      padding: 0;
      white-space: pre;
      border: none;
      background: transparent;
    }

    .highlight pre {
      background-color: #f8f8f8;
      border: 1px solid #cccccc;
      font-size: 13px;
      line-height: 19px;
      overflow: auto;
      padding: 6px 10px;
      border-radius: 3px;
    }

    pre {
      background-color: #f8f8f8;
      border: 1px solid #cccccc;
      font-size: 13px;
      line-height: 19px;
      overflow: auto;
      padding: 6px 10px;
      border-radius: 3px;
    }

    pre code, pre tt {
      background-color: transparent;
      border: none;
    }

    span.line-numbers {
      margin-right: 10px;
    }

    img.logo {
      display: block;
      margin: 10px auto;
    }

    h1.logo {
      text-align: center;
      font-size: 40px;
    }
  </style>
</head>
<body>
  <div id="containter">
    <h1 class="logo">Practicing Ruby</h1>
    <img class="logo" src="../images/header.png" />
    <blockquote>
  <p>Note: This article series on modules is also available as a <a href="https://github.com/elm-city-craftworks/pr-monthly/blob/gh-pages/b5e5a89847701c4aa7c170cf/sept-2012-modules.pdf?raw=true">PDF download</a>. The
PDF version has been revised and is more up-to-date than what you see here.</p>
</blockquote>

<p>Modules are part of what makes Ruby’s design beautiful. However, since they do not have a direct analogy in any mainstream programming language, it is easy to get a bit confused about what they should be used for. While most folks quickly encounter at least some of their use cases, typically only very experienced Ruby developers know their true versatilty.</p>

<p>In this four part article series, I aim to demystify Ruby modules by showing many practical use cases, explaining some tricky details along the way. We’ll work through some of the fundamentals in the first two issues, and move into more advanced examples in the second two. Today we’ll kick off this series by looking at the most simple, but perhaps most important ability modules offer us, the creation of namespaces.</p>

<h3 id="modules-for-namespacing">Modules for Namespacing</h3>

<p>Imagine that you are writing an XML generation library, and in it, you have a class to generate your XML documents. Perhaps uncreatively, you choose the name <code>Document</code> for your class, creating something similar to what is shown below.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Document</span>
  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">generate</span>
    <span style="color:#777"># ...</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>On its own, this seems to make a lot of sense; a user could do something simple like the following to make use of your library.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>require <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">your_xml_lib</span><span style="color:#710">&quot;</span></span>
document = <span style="color:#036;font-weight:bold">Document</span>.new
<span style="color:#777"># do something with document</span>
puts document.generate
</pre></div>
</div>
</div>

<p>But imagine that you were using another library that generates PDF documents, which happens to use similar uncreative naming for its class that does the PDF document generation. Then, the following code would look equally valid.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>require <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">their_pdf_lib</span><span style="color:#710">&quot;</span></span>
document = <span style="color:#036;font-weight:bold">Document</span>.new
<span style="color:#777"># do something with document</span>
puts document.generate
</pre></div>
</div>
</div>

<p>As long as the two libraries were never loaded at the same time, there would be no issue. But as soon as someone loaded both libraries, some quite confusing behavior would happen. One might think that defining two different classes with the same name would lead to some sort of error being raised by Ruby, but with open classes, that is not the case. Ruby would actually apply the definitions of <code>Document</code> one after the other, with whatever file was required last taking precedence. The end result would in all likelihood be a very broken <code>Document</code> class that could generate neither XML nor PDF.</p>

<p>But there is no reason for this to happen, as long as both libraries take care to namespace things. Shown below is an example of two <code>Document</code> classes that could co-exist peacefully.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#777"># somewhere in your_xml_lib</span>

<span style="color:#080;font-weight:bold">module</span> <span style="color:#B06;font-weight:bold">XML</span>
  <span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Document</span>
    <span style="color:#777"># ...</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>

<span style="color:#777"># somewhere in their_pdf_lib</span>

<span style="color:#080;font-weight:bold">module</span> <span style="color:#B06;font-weight:bold">PDF</span>
  <span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Document</span>
    <span style="color:#777"># ...</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>Using both classes in the same application is as easy, as long as you explicitly include the namespace when referring to each library’s <code>Document</code> class.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>require <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">your_xml_lib</span><span style="color:#710">&quot;</span></span>
require <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">their_pdf_lib</span><span style="color:#710">&quot;</span></span>

<span style="color:#777"># this pair of calls refer to two completely different classes</span>
pdf_document = <span style="color:#036;font-weight:bold">PDF</span>::<span style="color:#036;font-weight:bold">Document</span>.new
xml_document = <span style="color:#036;font-weight:bold">XML</span>::<span style="color:#036;font-weight:bold">Document</span>.new
</pre></div>
</div>
</div>

<p>The clash has been prevented because each library has nested its <code>Document</code> class within a module, allowing the class to be defined within that namespace rather than at the global level. While this is a relatively straightforward concept, it’s important to note a few things about what is really going on here.</p>

<p>Firstly, namespacing actually applies to the way constants are looked up in Ruby in general, not classes in particular. This means that it applies to modules nested within modules as well as ordinary constants as well.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">module</span> <span style="color:#B06;font-weight:bold">A</span>
  <span style="color:#080;font-weight:bold">module</span> <span style="color:#B06;font-weight:bold">B</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>

p <span style="color:#036;font-weight:bold">A</span>::<span style="color:#036;font-weight:bold">B</span>

<span style="color:#080;font-weight:bold">module</span> <span style="color:#B06;font-weight:bold">A</span>
  <span style="color:#036;font-weight:bold">C</span> = <span style="color:#00D">10</span>
<span style="color:#080;font-weight:bold">end</span>

p <span style="color:#036;font-weight:bold">A</span>::<span style="color:#036;font-weight:bold">C</span>
</pre></div>
</div>
</div>

<p>Secondly, this same behavior of using modules as namespaces applies just as well to classes, as in the code below.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Blog</span>
  <span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Comment</span>
    <span style="color:#777">#...</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>Be sure to note that in this example, nesting a class within a class does not in any way make it a subclass or establish any relationship between <code>Blog</code> and <code>Blog::Comment</code> except that <code>Blog::Comment</code> is within the <code>Blog</code> namespace. In the example below, you can see that a class nested within another class looks the same as a class nested within a module.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>blog = <span style="color:#036;font-weight:bold">Blog</span>.new
comment = <span style="color:#036;font-weight:bold">Blog</span>::<span style="color:#036;font-weight:bold">Comment</span>.new
<span style="color:#777"># ...</span>
</pre></div>
</div>
</div>

<p>Of course, this technique is only really useful when you have a desired namespace for your library that also happens matches one of your class names. In all other situations, it makes sense to use a module for namespacing as it would prevent your users from creating instances of an empty and meaningless class.</p>

<p>Finally, it is important to understand that constants are looked up from the innermost nesting to the outermost, finally searching the global namespace. This can be a bit confusing at times, especially when you consider some corner cases.</p>

<p>For example, examine the following code:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">module</span> <span style="color:#B06;font-weight:bold">FancyReporter</span>
  <span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Document</span>
    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">initialize</span>
       <span style="color:#33B">@output</span> = <span style="color:#036;font-weight:bold">String</span>.new
    <span style="color:#080;font-weight:bold">end</span>

    attr_reader <span style="color:#A60">:output</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>If you load this code into irb and play with a bit on its own, you can inspect an instance of Document to see that its output attribute is a core ruby <code>String</code> object, as shown below:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>&gt;&gt; <span style="color:#036;font-weight:bold">FancyReporter</span>::<span style="color:#036;font-weight:bold">Document</span>.new.output
=&gt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#710">&quot;</span></span>
&gt;&gt; <span style="color:#036;font-weight:bold">FancyReporter</span>::<span style="color:#036;font-weight:bold">Document</span>.new.output.class
=&gt; <span style="color:#036;font-weight:bold">String</span>
</pre></div>
</div>
</div>

<p>While this seems fairly obvious, it is easy for a bit of unrelated code written elsewhere to change everything. Consider the following code:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">module</span> <span style="color:#B06;font-weight:bold">FancyReporter</span>
  <span style="color:#080;font-weight:bold">module</span> <span style="color:#B06;font-weight:bold">String</span>
    <span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Formatter</span>
    <span style="color:#080;font-weight:bold">end</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>While the designer of <code>FancyReporter</code> was most likely trying to be well organized by offering <code>FancyReporter::String::Formatter</code>, this small change causes headaches because it changes the meaning of <code>String.new</code> in <code>Document</code>’s initialize method. In fact, you cannot even create an instance of <code>Document</code> before the following error is raised:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#00D">?&gt;</span> <span style="color:#036;font-weight:bold">FancyReporter</span>::<span style="color:#036;font-weight:bold">Document</span>.new
<span style="color:#606">NoMethodError</span>: undefined method <span style="background-color:hsla(120,100%,50%,0.06)"><span style="color:#161">`</span><span style="color:#2B2">new' for FancyReporter::String:Module
        from (irb):35:in </span><span style="color:#161">`</span></span>initialize<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">
        from (irb):53:in `new</span><span style="color:#710">'</span></span>
        from (irb):<span style="color:#00D">53</span>
</pre></div>
</div>
</div>

<p>There are a number of ways this problem can be avoided. Often times, it’s
possible to come up with alternative names that do not clash with core objects,
and when that’s the case, it’s preferable. In this particular case, <code>String.new</code>
can also be replaced with <code>""</code>, as nothing can change what objects are created
via Ruby’s string literal syntax. But there is also an approach that works
independent of context, and that is to use explicit constant lookups from the
global namespace. You can see an example of explicit lookups in the following
code:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">module</span> <span style="color:#B06;font-weight:bold">FancyReporter</span>
  <span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Document</span>
    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">initialize</span>
       <span style="color:#33B">@output</span> = ::<span style="color:#036;font-weight:bold">String</span>.new
    <span style="color:#080;font-weight:bold">end</span>

    attr_reader <span style="color:#A60">:output</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>Prepending any constant with <code>::</code> will force Ruby to skip the nested namespaces and bubble all the way up to the root. In this sense, the difference between <code>A::B</code> and <code>::A::B</code> is that the former is a sort of relative lookup whereas the latter is absolute from the root namespace.</p>

<p>In general, having to use absolute lookups may be a sign that there is an unnecessary name conflict within your application. But if upon investigation you find names that inheritently collide with one another, you can use this tool to avoid any ambiguity in your code.</p>

<p>While we’ve mostly covered the mechanics of namespacing, all this talk about <code>::</code> compels me to share a cautionary tale of mass cargoculting before we wrap up for today. Please bear with me as I stroke my beard for a moment.</p>

<h3 id="abusing-the-constant-lookup-operator-">Abusing the Constant Lookup Operator (<code>::</code>)</h3>

<p>In some older documentation, and some relatively recent code written by folks who learned from old documentation, you may see class methods being called in the manner shown below.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#036;font-weight:bold">YAML</span>::load(<span style="color:#036;font-weight:bold">File</span>::read(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">foo.yaml</span><span style="color:#710">&quot;</span></span>))
</pre></div>
</div>
</div>

<p>While the above code runs fine, it’s only a historical accident that it does. In fact, <code>::</code> was never meant for method invocation, class methods or otherwise. You can easily demonstrate that <code>::</code> can be used to execute instance methods as well, which eliminates any notion that <code>::</code> has some special ‘class methods only’ distinction to it.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">foo</span><span style="color:#710">&quot;</span></span>::reverse <span style="color:#777">#=&gt; &quot;oof&quot;</span>
</pre></div>
</div>
</div>

<p>As far as I can tell, this style of method invocation actually came about as a documentation convention. In both formal documentation and in mailing list discussions, it can sometimes be difficult to discern whether someone is talking about a class method or instance method, since both can be called just as well with the dot operator. So, a convention was invented so that for a class <code>Foo</code>, the instance method <code>bar</code> would be referred to as <code>Foo#bar</code>, and the class method <code>bar</code> would be referred to as <code>Foo::bar</code>. This did away with the dot entirely, leaving no room for ambiguity.</p>

<p>Unfortunately, this lead to a confusing situation. Beginners would often type <code>Foo#bar</code> to try to call instance methods, but were at least promptly punished for doing so because such code will not run at all. However, typing <code>Foo::bar</code> does work! Thus, an entire generation of Ruby developers were born thinking that <code>::</code> is some sort of special operator for calling class methods, and to an extent, others followed suit as a new convention emerged.</p>

<p>The fact that <code>::</code> will happily call methods for you has to do with internal implementation details of MRI, and so it’s actually an undefined behavior, subject to change. As far as I know, there is no guarantee it will actually work as expected, and so it shouldn’t be relied upon.</p>

<p>In your code, you should feel free to replace any method calls that use this style with ordinary <code>Foo.bar</code> calls. This actually reflects more of the true nature of Ruby, in that it doesn’t emphasize the difference between class level calls and instance level calls, since that distinction isn’t especially important. In documentation, things are a little trickier, but it is now generally accepted that <code>Foo.bar</code> refers to a class method and <code>Foo#bar</code> refers to an instance method. In cases where that distinction alone might be confusing, you could always be explicit, as in the example below.</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>obj.bar <span style="color:#777"># obj is an instance of Foo</span>
</pre></div>
</div>
</div>

<p>If this argument wasn’t convincing enough, you should know that every time you replace a <code>Foo::bar</code> call with <code>Foo.bar</code>, a brand new baby unicorn is born beneath a magnificent double rainbow. That should be reason enough to reverse this outdated practice, right?</p>

<h3 id="reflections">Reflections</h3>

<p>This article probably gave you more details than you ever cared to know about namespacing. But future articles will be sure to blow your mind with what else modules can do. However, if you have any questions or thoughts about what we’ve discussed so far, feel free to leave them in the comments section below.</p>

<blockquote>
  <p><strong>NOTE:</strong> This article has also been published on the Ruby Best Practices blog. There <a href="http://blog.rubybestpractices.com/posts/gregory/037-issue-8-uses-for-modules.html#disqus_thread">may be additional commentary</a> 
over there worth taking a look at.</p>
</blockquote>

  </div>
</body>
</html>

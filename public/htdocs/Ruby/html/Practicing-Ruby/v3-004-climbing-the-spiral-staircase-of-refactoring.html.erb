<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/>
  <title>Practicing Ruby</title>
  <style>
    body {
      font-family: "Helvetica Neue", arial, sans-serif;
      font-size: 14px;
      line-height: 1.6;
      padding-top: 10px;
      padding-bottom: 10px;
      background-color: white;
      padding: 30px;
      color: #333;
      border: 1px solid #aaa;
      max-width: 900px;
      margin: 20px auto;
    }

    body > *:first-child {
      margin-top: 0 !important;
    }

    body > *:last-child {
      margin-bottom: 0 !important;
    }

    a {
      color: #4183C4;
      text-decoration: none;
    }

    a.absent {
      color: #cc0000;
    }

    a.anchor {
      display: block;
      padding-left: 30px;
      margin-left: -30px;
      cursor: pointer;
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
    }

    h1, h2, h3, h4, h5, h6 {
      margin: 20px 0 10px;
      padding: 0;
      font-weight: bold;
      -webkit-font-smoothing: antialiased;
      cursor: text;
      position: relative;
    }

    h2:first-child, h1:first-child, h1:first-child + h2, h3:first-child, h4:first-child, h5:first-child, h6:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
      text-decoration: none;
    }

    h1 tt, h1 code {
      font-size: inherit;
    }

    h2 tt, h2 code {
      font-size: inherit;
    }

    h3 tt, h3 code {
      font-size: inherit;
    }

    h4 tt, h4 code {
      font-size: inherit;
    }

    h5 tt, h5 code {
      font-size: inherit;
    }

    h6 tt, h6 code {
      font-size: inherit;
    }

    h1 {
      font-size: 28px;
      color: black;
    }

    h2 {
      font-size: 24px;
      border-bottom: 1px solid #cccccc;
      color: black;
    }

    h3 {
      font-size: 18px;
    }

    h4 {
      font-size: 16px;
    }

    h5 {
      font-size: 14px;
    }

    h6 {
      color: #777777;
      font-size: 14px;
    }

    p, blockquote, ul, ol, dl, li, table, pre {
      margin: 3px 0;
    }

    hr {
      background: transparent url("http://tinyurl.com/bq5kskr") repeat-x 0 0;
      border: 0 none;
      color: #cccccc;
      height: 4px;
      padding: 0;
    }

    body > h2:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    body > h1:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    body > h1:first-child + h2 {
      margin-top: 0;
      padding-top: 0;
    }

    body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
      margin-top: 0;
      padding-top: 0;
    }

    h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
      margin-top: 0;
    }

    li p.first {
      display: inline-block;
    }

    ul, ol {
      padding-left: 30px;
    }

    ul :first-child, ol :first-child {
      margin-top: 0;
    }

    ul :last-child, ol :last-child {
      margin-bottom: 0;
    }

    dl {
      padding: 0;
    }

    dl dt {
      font-size: 14px;
      font-weight: bold;
      font-style: italic;
      padding: 0;
      margin: 15px 0 5px;
    }

    dl dt:first-child {
      padding: 0;
    }

    dl dt > :first-child {
      margin-top: 0;
    }

    dl dt > :last-child {
      margin-bottom: 0;
    }

    dl dd {
      margin: 0 0 15px;
      padding: 0 15px;
    }

    dl dd > :first-child {
      margin-top: 0;
    }

    dl dd > :last-child {
      margin-bottom: 0;
    }

    blockquote {
      border-left: 4px solid #dddddd;
      padding: 0 15px;
      color: #777777;
    }

    blockquote > :first-child {
      margin-top: 0;
    }

    blockquote > :last-child {
      margin-bottom: 0;
    }

    table {
      padding: 0;
    }
    table tr {
      border-top: 1px solid #cccccc;
      background-color: white;
      margin: 0;
      padding: 0;
    }

    table tr:nth-child(2n) {
      background-color: #f8f8f8;
    }

    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      text-align: left;
      margin: 0;
      padding: 6px 13px;
    }

    table tr td {
      border: 1px solid #cccccc;
      text-align: left;
      margin: 0;
      padding: 6px 13px;
    }

    table tr th :first-child, table tr td :first-child {
      margin-top: 0;
    }

    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0;
    }

    img {
      max-width: 100%;
    }

    span.frame {
      display: block;
      overflow: hidden;
    }

    span.frame > span {
      border: 1px solid #dddddd;
      display: block;
      float: left;
      overflow: hidden;
      margin: 13px 0 0;
      padding: 7px;
      width: auto;
    }

    span.frame span img {
      display: block;
      float: left;
    }

    span.frame span span {
      clear: both;
      color: #333333;
      display: block;
      padding: 5px 0 0;
    }

    span.align-center {
      display: block;
      overflow: hidden;
      clear: both;
    }

    span.align-center > span {
      display: block;
      overflow: hidden;
      margin: 13px auto 0;
      text-align: center;
    }

    span.align-center span img {
      margin: 0 auto;
      text-align: center;
    }

    span.align-right {
      display: block;
      overflow: hidden;
      clear: both;
    }

    span.align-right > span {
      display: block;
      overflow: hidden;
      margin: 13px 0 0;
      text-align: right;
    }

    span.align-right span img {
      margin: 0;
      text-align: right;
    }

    span.float-left {
      display: block;
      margin-right: 13px;
      overflow: hidden;
      float: left;
    }

    span.float-left span {
      margin: 13px 0 0;
    }

    span.float-right {
      display: block;
      margin-left: 13px;
      overflow: hidden;
      float: right;
    }

    span.float-right > span {
      display: block;
      overflow: hidden;
      margin: 13px auto 0;
      text-align: right;
    }

    code, tt {
      font-family: "Lucida Console", "Courier New", courier;
      font-size: 12px;
      margin: 0 2px;
      padding: 3px 5px;
      white-space: nowrap;
      border: 1px solid #eaeaea;
      background-color: #f8f8f8;
      border-radius: 3px;
    }

    pre code {
      margin: 0;
      padding: 0;
      white-space: pre;
      border: none;
      background: transparent;
    }

    .highlight pre {
      background-color: #f8f8f8;
      border: 1px solid #cccccc;
      font-size: 13px;
      line-height: 19px;
      overflow: auto;
      padding: 6px 10px;
      border-radius: 3px;
    }

    pre {
      background-color: #f8f8f8;
      border: 1px solid #cccccc;
      font-size: 13px;
      line-height: 19px;
      overflow: auto;
      padding: 6px 10px;
      border-radius: 3px;
    }

    pre code, pre tt {
      background-color: transparent;
      border: none;
    }

    span.line-numbers {
      margin-right: 10px;
    }

    img.logo {
      display: block;
      margin: 10px auto;
    }

    h1.logo {
      text-align: center;
      font-size: 40px;
    }
  </style>
</head>
<body>
  <div id="containter">
    <h1 class="logo">Practicing Ruby</h1>
    <img class="logo" src="../images/header.png" />
    <p>In <a href="http://practicingruby.com/articles/shared/bwgflabwncjv">Issue 3.3</a>, I presented a proof-of-concept Ruby implementation of the <a href="http://en.wikipedia.org/wiki/Brainfuck">Brainfuck programming language</a> and challenged Practicing Ruby readers to improve upon it. After receiving several patches that helped move things along, I sat down once again to clean up the code even further. What I came to realize as I worked on my revisions is that the refactoring process is very similar to climbing a spiral staircase. Each structural change to the code simultaneously left the project back where it started along one vector while moving it forward along another.</p>

<p>Because we often look at the merits of a given refactoring technique within the context of a single transition from worse code to better code, it’s easy to mistakenly assume that the refactoring process is much more linear than it actually is. In this article, I’ve tried to capture a much wider angle view of how refactoring really works in the wild. The end result is a story which I hope will spark some good discussions about how we can improve our code quality over time.</p>

<h3 id="prologue-everything-has-to-start-somewhere">Prologue. Everything has to start somewhere</h3>

<p>I decided to name my interpreter <a href="http://en.wikipedia.org/wiki/Turing_tarpit">Turing Tarpit</a>, because that term is perfectly apt for describing languages like Brainfuck. In a nutshell, the term refers to any language which is infinitely flexible, yet nearly impossible to use for anything practical. It turns out that building this sort of mind trap for programmers is quite easy to do.</p>

<p>My first iteration was easy enough to build, and consisted of three objects: a <code>Tape</code>, an <code>Interpreter</code>, and a <code>Scanner</code>. The rough breakdown of responsibilities was something like this:</p>

<ul>
  <li>
    <p>The <a href="https://github.com/elm-city-craftworks/turing_tarpit/blob/starting_point/lib/turing_tarpit.rb#L103-149">Tape object</a> implemented something similar to the storage mechanism in a <a href="http://en.wikipedia.org/wiki/Turing_machine#Informal_description">Turing machine</a>. It provided mechanisms for accessing and modifying numeric values in cells, as well as a way to increment and decrement the pointer that determined which cell to operate on.</p>
  </li>
  <li>
    <p>The <a href="https://github.com/elm-city-craftworks/turing_tarpit/blob/starting_point/lib/turing_tarpit.rb#L7-34">Interpreter object</a> served as a mapping between Brainfuck’s symbolic operators and the operations provided by the <code>Tape</code> object. It also implemented the I/O functionality required by Brainfuck.</p>
  </li>
  <li>
    <p>The <a href="https://github.com/elm-city-craftworks/turing_tarpit/blob/starting_point/lib/turing_tarpit.rb#L36-69">Scanner object</a> was responsible for taking a Brainfuck source file as input and transforming it into a stream of operations that could be handled by the <code>Interpreter</code> object. For the most part this simply meant reading the source file one character at a time, but this object also needed to account for Brainfuck’s forward and backward jump operations.</p>
  </li>
</ul>

<p>While my initial implementation was reasonably clean for a proof-of-concept, it definitely had room for improvement. I decided to ask for feedback early in the hopes that folks would find and fix the things I knew were problematic while simultaneously checking my blindspots for issues that I hadn’t noticed myself.</p>

<h3 id="act-i-getting-a-fresh-perspective-on-the-problem">Act I. Getting a fresh perspective on the problem</h3>

<p>Some of the issues brought up by contributors were fairly obvious housekeeping chores, but nonetheless made the project nicer to work with:</p>

<ul>
  <li>
    <p>Steve Klabnik <a href="https://github.com/elm-city-craftworks/turing_tarpit/pull/3">requested a way to run the whole test suite at once</a> instead of file by file. He had provided a patch with a Rakefile, but since the project didn’t have any immediate need for other rake tasks, we ended up deciding that a simple <em>test/suite.rb</em> file would be sufficient. Notes were added to the README on how to run the tests.</p>
  </li>
  <li>
    <p>Renato Riccieri <a href="https://github.com/elm-city-craftworks/turing_tarpit/pull/6">broke the classes out into individual files</a>. The original implementation had everything in <em>lib/turing_tarpit.rb</em>, simply for convenience reasons while spiking. Breaking the classes into individual files brought the project more in line with <a href="http://chneukirchen.github.com/rps/">standard Ruby packaging conventions</a>.</p>
  </li>
  <li>
    <p>Benoit Daloze <a href="https://github.com/elm-city-craftworks/turing_tarpit/pull/2">refactored some ugly output code</a> to use <code>putc(char)</code> instead of <code>print("" &lt;&lt; char)</code>. Since the latter was obviously a hack due to my lack of awareness of the <code>putc</code> method, this was a welcome contribution.</p>
  </li>
</ul>

<p>After this initial round of cleanup, we ended up thinking through a pair of more substantial problems: the inconsitent use of private accessors, and a proposed refactoring to break up the <code>Scanner</code> object into two separate objects, a <code>Tokenizer</code> and a <code>Scanner</code>.</p>

<p><strong>The story behind my recent private accessor experiments</strong></p>

<p>Ryan LeCompte was the one to bring up <a href="https://github.com/elm-city-craftworks/turing_tarpit/issues/1">the question about private accessors</a>, and was curious about why I had used them in some places but referenced instance variables directly in others. The main reason for this was simply that the use of private accessors is a new experiment for me, and so in my haste of getting a first version out the door, I remembered to use them in some places but not in others.</p>

<p>This project in particular posed certain challenges for using private accessors conveniently. A specific example of where I ran into some weird edge cases can easily be seen in the <code>Tape</code> object:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">module</span> <span style="color:#B06;font-weight:bold">TuringTarpit</span>
  <span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Tape</span>
    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">initialize</span>
      <span style="color:#069">self</span>.pointer_position = <span style="color:#00D">0</span>
      <span style="color:#777"># ...</span>
    <span style="color:#080;font-weight:bold">end</span>

    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">increment_pointer</span>
      <span style="color:#069">self</span>.pointer_position = pointer_position + <span style="color:#00D">1</span>
    <span style="color:#080;font-weight:bold">end</span>

    <span style="color:#777"># ...</span>

    private

    attr_writer <span style="color:#A60">:pointer_position</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>If you just glance quickly at this class definition, it is very tempting to try to refactor <code>increment_pointer</code> so that it uses convenient <code>+=</code> syntax, resulting in something like the code below:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">increment_pointer</span>
  <span style="color:#069">self</span>.pointer_position += <span style="color:#00D">1</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>In most cases, this refactoring would be a good one because it makes the code slightly less verbose without sacrificing readability. However, it turns out that Ruby does not extend the same private method special casing to <code>self.foo += something</code> as it does to <code>self.foo = something</code>. This means that if you attempt to refactor this code to use <code>+=</code> it ends up raising a <code>NoMethodError</code>. Because this is definitely a downside of using private accessors, it’s reasonable to ask why you’d bother to use them in the first place rather than using public accessors or simply referring to instance variables directly.</p>

<p>The best reason I can find for making use of accessors in general vs. instance variables is simply that the former are much more flexible. New behavior such as validations or transformations can be added later by changing what used to be vanilla accessors into ordinary method definitions. Additionally, if you accidentally introduce a typo into your code, you will get a <code>NoMethodError</code> right away rather than having to track down why your attribute is <code>nil</code> when you didn’t expect it to be in some completely different place in your code.</p>

<p>The problem with making accessors public is that it hints to the consumer that it is meant to be touched and used, which is often not the case at all, especially for writers. While Ruby makes it trivial to circumvent privacy protections, a private method communicates to the user that it is meant to be treated as an implementation detail and should not be depended on. So the reason for using a private accessor is the same as the reason for using a private method: to mark the accessor as part of the internals of the object.</p>

<p>The interesting thing I stumbled across in this particular project is that if you take this technique to the extreme, it is possible to build entire applications without ever explicitly referencing an instance variable. It comes at the cost of the occasional weird edge case when calling private methods internally, but makes it possible to treat instance variables as a whole as a <em>language implementation detail</em>, rather than an <em>application implementation detail</em>. Faced with the opportunity to at least experiment with that idea, I decided to make the entire Turing Tarpit codebase completely free of instance variables, which ended up taking very little effort.</p>

<p>The jury is still out on whether or not this is a good idea, but I plan to keep trying the idea out in my projects and see whether I run into any more issues. If I don’t experience problems, I’d say this technique is well worth it because it emphasizes message-passing rather than state manipulation in our objects. </p>

<p><strong>Splitting up the Scanner object</strong></p>

<p>After helping out with a few of the general housekeeping chores, Steve Klabnik then turned his attention to one of the weakest spots in the code, the <code>Scanner</code> object. He pointed out that having an object with dependencies on a whole lot of private methods is a bit of a code smell, and focused specifically on the <code>Scanner#next</code> method. The original implementation looked like this:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">module</span> <span style="color:#B06;font-weight:bold">TuringTarpit</span>
  <span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Scanner</span>
    <span style="color:#777"># ...</span>

    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">next</span>(cell_value)
      validate_index

      element = <span style="color:#33B">@chars</span>[<span style="color:#33B">@index</span>]
      
      <span style="color:#080;font-weight:bold">case</span> element
      <span style="color:#080;font-weight:bold">when</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">[</span><span style="color:#710">&quot;</span></span>
        jump_forward <span style="color:#080;font-weight:bold">if</span> cell_value.zero?

        consume
        element = <span style="color:#33B">@chars</span>[<span style="color:#33B">@index</span>]
      <span style="color:#080;font-weight:bold">when</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">]</span><span style="color:#710">&quot;</span></span>
        <span style="color:#080;font-weight:bold">if</span> cell_value.zero?
          <span style="color:#080;font-weight:bold">while</span> element == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">]</span><span style="color:#710">&quot;</span></span>
            consume
            element = <span style="color:#33B">@chars</span>[<span style="color:#33B">@index</span>]
            validate_index
          <span style="color:#080;font-weight:bold">end</span>
        <span style="color:#080;font-weight:bold">else</span>
          jump_back
          consume
          element = <span style="color:#33B">@chars</span>[<span style="color:#33B">@index</span>]
        <span style="color:#080;font-weight:bold">end</span>
      <span style="color:#080;font-weight:bold">end</span>
      
      consume
      element
    <span style="color:#080;font-weight:bold">end</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>Steve pointed out that the <code>Scanner#next</code> method was really doing more of a tokenizing operation, and that most of the scanning work was actually being done by the various private methods that were being used to traverse the underlying string. He prepared a patch which made this relationship explicit by introducing a <code>Tokenizer</code> object which would provide a method to replace <code>Scanner#next</code>. His newly introduced object allowed for a re-purposing of the <code>Scanner</code> object which allowed its methods to become public:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">module</span> <span style="color:#B06;font-weight:bold">TuringTarpit</span>
  <span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Tokenizer</span>
    <span style="color:#777"># ...</span>

    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">next</span>(cell_value)
      scanner.validate_index

      element = scanner.current_char

      <span style="color:#080;font-weight:bold">case</span> element
      <span style="color:#080;font-weight:bold">when</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">[</span><span style="color:#710">&quot;</span></span>
        scanner.jump_forward <span style="color:#080;font-weight:bold">if</span> cell_value.zero?

        scanner.consume
        element = scanner.current_char
      <span style="color:#080;font-weight:bold">when</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">]</span><span style="color:#710">&quot;</span></span>
        <span style="color:#080;font-weight:bold">if</span> cell_value.zero?
          <span style="color:#080;font-weight:bold">while</span> element == <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">]</span><span style="color:#710">&quot;</span></span>
            scanner.consume
            element = scanner.current_char
            scanner.validate_index
          <span style="color:#080;font-weight:bold">end</span>
        <span style="color:#080;font-weight:bold">else</span>
          scanner.jump_back
          scanner.consume
          element = scanner.current_char
        <span style="color:#080;font-weight:bold">end</span>
      <span style="color:#080;font-weight:bold">end</span>

      scanner.consume
      element
    <span style="color:#080;font-weight:bold">end</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>The thing in particular I liked about this patch is that it abstracted away some of the tedious index operations that were originally present in <code>Scanner#next</code>. As much as possible I prefer to isolate anything that can cause off-by-one errors or other such nonsense, and this refactoring did a good job of addressing that issue.</p>

<p>The interesting thing about this refactoring is that while I intended to work on the same area of the code if no one else patched it, I had planned to approach it in a very different way. My original idea was to implement some sort of generic stream datastructure and reuse it in both <code>Scanner</code> and <code>Tape</code>. However, seeing that Steve’s patch at least partly addressed my concerns while possibly opening some new avenues as well, I abandoned that idea and merged his work instead.</p>

<h3 id="act-ii-building-a-better-horse">Act II. Building a better horse</h3>

<p>After applying the various patches from the folks who participated in this challenge, the code was in a much better place than where it started. However, much work was still left to be done!</p>

<p>In particular, the code responsible for turning Brainfuck syntax into a stream of operations still needed a lot of work. The <code>Tokenizer</code> class that Steve introduced was an improvement, but without further revisions would simply serve as a layer of indirection rather than as an abstraction. Zed Shaw describes the difference between these two concepts very eloquently in his essay <a href="http://zedshaw.com/essays/indirection_is_not_abstraction.html">Indirection Is Not Abstraction</a> by stating that <em>“Abstraction is used to reduce complexity. Indirection is used to reduce coupling or dependence.”</em></p>

<p>As far as the <code>Tokenizer</code> object goes, Steve’s patch reducing coupling somewhat by pushing some of the implementation details down into the <code>Scanner</code> object. However, the procedure is pretty much identical with the exception of the lack of explicit indexing code, and so the baseline complexity actually increases because what was once done by one object is now split across two objects.</p>

<p>To address this problem, the dividing lines between the two objects needed to be leveraged so that they could interact with each other at a higher level. It took me a while to think through the problem, but in doing so I realized that I could now push more functionality down into the <code>Scanner</code> object so that <code>Tokenizer#next</code> ended up with fewer moving parts. After some major gutting and re-arranging, I ended up with a method that looked like this:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">module</span> <span style="color:#B06;font-weight:bold">TuringTarpit</span>
  <span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Tokenizer</span>
    <span style="color:#777"># ...</span>

    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">next</span>(cell_value)
      <span style="color:#080;font-weight:bold">case</span> scanner.next_char
      <span style="color:#080;font-weight:bold">when</span> <span style="color:#036;font-weight:bold">Scanner</span>::<span style="color:#036;font-weight:bold">FORWARD_JUMP</span>
        <span style="color:#080;font-weight:bold">if</span> cell_value.zero?
          scanner.jump_forward
        <span style="color:#080;font-weight:bold">else</span>
          scanner.next_char
        <span style="color:#080;font-weight:bold">end</span>
      <span style="color:#080;font-weight:bold">when</span> <span style="color:#036;font-weight:bold">Scanner</span>::<span style="color:#036;font-weight:bold">BACKWARD_JUMP</span>
        <span style="color:#080;font-weight:bold">if</span> cell_value.zero?
          scanner.skip_while(<span style="color:#036;font-weight:bold">Scanner</span>::<span style="color:#036;font-weight:bold">BACKWARD_JUMP</span>)
        <span style="color:#080;font-weight:bold">else</span>
          scanner.jump_back
        <span style="color:#080;font-weight:bold">end</span>
      <span style="color:#080;font-weight:bold">end</span>

      scanner.current_char
    <span style="color:#080;font-weight:bold">end</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>After this refactoring, the <code>Tokenizer#next</code> method was a good deal more abstract in a number of ways:</p>

<ul>
  <li>
    <p>It expected the <code>Scanner</code> to handle validations itself rather than telling it when to check the index </p>
  </li>
  <li>
    <p>It no longer referenced Brainfuck syntax and instead used constants provided by the <code>Scanner</code></p>
  </li>
  <li>
    <p>It eliminated a lot of cumbersome assignments by reworking its algorithm so that <code>Scanner#current_char</code> always referenced the right character at the end of the scanning routine.</p>
  </li>
  <li>
    <p>It expected the <code>Scanner</code> to remain internally consistent, rather than handling edge cases itself.</p>
  </li>
</ul>

<p>These reductions in complexity made a hugely positive impact on the readability and understandability of the <code>Tokenizer#next</code> method. While all of these changes could have technically been made before the split between the <code>Scanner</code> and <code>Tokenizer</code> happened, cutting the knot into two pieces certainly made untangling things easier. This is why indirection and abstraction often go hand in hand, despite the fact that they are very different concepts from one another.</p>

<h3 id="act-iii-mountains-are-once-again-merely-mountains">Act III. Mountains are once again merely mountains</h3>

<p>After building on top of Steve’s work to simplify the syntax-processing code even further, I finally felt like that part of the project was in decent shape. I then decided to turn my attention back to the <code>Interpreter</code> object, since it had not received any love from the challenge participants. The original code for it looked something like this:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">module</span> <span style="color:#B06;font-weight:bold">TuringTarpit</span>
  <span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Interpreter</span>
    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">run</span>
      loop <span style="color:#080;font-weight:bold">do</span>
        <span style="color:#080;font-weight:bold">case</span> tokenizer.next(tape.cell_value)
        <span style="color:#080;font-weight:bold">when</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">+</span><span style="color:#710">&quot;</span></span>
          tape.increment_cell_value
        <span style="color:#080;font-weight:bold">when</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">-</span><span style="color:#710">&quot;</span></span>
          tape.decrement_cell_value
        <span style="color:#080;font-weight:bold">when</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">&gt;</span><span style="color:#710">&quot;</span></span>
          tape.increment_pointer
        <span style="color:#080;font-weight:bold">when</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">&lt;</span><span style="color:#710">&quot;</span></span>
          tape.decrement_pointer
        <span style="color:#080;font-weight:bold">when</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">.</span><span style="color:#710">&quot;</span></span>
          putc(tape.cell_value)
        <span style="color:#080;font-weight:bold">when</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">,</span><span style="color:#710">&quot;</span></span>
          value = <span style="color:#069">STDIN</span>.getch.bytes.first
          <span style="color:#080;font-weight:bold">next</span> <span style="color:#080;font-weight:bold">if</span> value.zero?

          tape.cell_value = value
        <span style="color:#080;font-weight:bold">end</span>
      <span style="color:#080;font-weight:bold">end</span>
    <span style="color:#080;font-weight:bold">end</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>While this implementation wasn’t too bad, there were two things I didn’t like about it. The first issue was that it directly referenced Brainfuck syntax, which sort of defeated the purpose of having the tokenizer be syntax independent. The second problem was that I found the case statement to feel a bit brittle and limiting. What I really wanted was a dynamic dispatcher similar to the following method:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">run</span>
  loop <span style="color:#080;font-weight:bold">do</span>
    <span style="color:#080;font-weight:bold">if</span> operation = tokenizer.next(evaluator.cell_value)
      tape.send(operation)
    <span style="color:#080;font-weight:bold">end</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>In order to introduce this kind of functionality, I’d need to find a place to introduce a simple mapping from Brainfuck syntax to operation names. I already had the keys and values in mind, I just needed to find a place to put them:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#036;font-weight:bold">OPERATIONS</span> = { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">+</span><span style="color:#710">&quot;</span></span> =&gt; <span style="color:#A60">:increment_cell_value</span>,
               <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">-</span><span style="color:#710">&quot;</span></span> =&gt; <span style="color:#A60">:decrement_cell_value</span>,
               <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">&gt;</span><span style="color:#710">&quot;</span></span> =&gt; <span style="color:#A60">:increment_pointer</span>,
               <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">&lt;</span><span style="color:#710">&quot;</span></span> =&gt; <span style="color:#A60">:decrement_pointer</span>,
               <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">.</span><span style="color:#710">&quot;</span></span> =&gt; <span style="color:#A60">:output_cell_value</span>,
               <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">,</span><span style="color:#710">&quot;</span></span> =&gt; <span style="color:#A60">:input_cell_value</span> }
</pre></div>
</div>
</div>

<p>Figuring out how to make this work was surprisingly challenging. I found that the extra layers of indirection between the <code>Tape</code> and the <code>Scanner</code> meant that any change made too far down the chain would need to be echoed all the way up it, and that changes made towards the top felt tacked on and out of place. This eventually led me to question what the separation between <code>Scanner</code> and <code>Tokenizer</code> was really gaining me, as well as the separation between <code>Interpreter</code> and <code>Tape</code>.</p>

<p>After a fair amount of ruminating, I decided to take my four objects and join them together at the seams so that only two remained. The <code>Scanner</code> and <code>Tokenizer</code> ended up getting joined back together to form a new <code>Interpreter</code> class. The job of the <code>Interpreter</code> is to take Brainfuck syntax and turn it into a stream of operations. You can get a rough idea of how it all came together by checking out the following code:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">module</span> <span style="color:#B06;font-weight:bold">TuringTarpit</span>
  <span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Interpreter</span>
    <span style="color:#036;font-weight:bold">FORWARD_JUMP</span> = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">[</span><span style="color:#710">&quot;</span></span>
    <span style="color:#036;font-weight:bold">BACKWARD_JUMP</span> = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">]</span><span style="color:#710">&quot;</span></span>

    <span style="color:#036;font-weight:bold">OPERATIONS</span> = { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">+</span><span style="color:#710">&quot;</span></span> =&gt; <span style="color:#A60">:increment_cell_value</span>,
                   <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">-</span><span style="color:#710">&quot;</span></span> =&gt; <span style="color:#A60">:decrement_cell_value</span>,
                   <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">&gt;</span><span style="color:#710">&quot;</span></span> =&gt; <span style="color:#A60">:increment_pointer</span>,
                   <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">&lt;</span><span style="color:#710">&quot;</span></span> =&gt; <span style="color:#A60">:decrement_pointer</span>,
                   <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">.</span><span style="color:#710">&quot;</span></span> =&gt; <span style="color:#A60">:output_cell_value</span>,
                   <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">,</span><span style="color:#710">&quot;</span></span> =&gt; <span style="color:#A60">:input_cell_value</span> }

    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">next_operation</span>(cell_value)
      <span style="color:#080;font-weight:bold">case</span> next_char
      <span style="color:#080;font-weight:bold">when</span> <span style="color:#036;font-weight:bold">FORWARD_JUMP</span>
        <span style="color:#080;font-weight:bold">if</span> cell_value.zero?
          jump_forward
        <span style="color:#080;font-weight:bold">else</span>
          skip_while(<span style="color:#036;font-weight:bold">FORWARD_JUMP</span>)
        <span style="color:#080;font-weight:bold">end</span>
      <span style="color:#080;font-weight:bold">when</span> <span style="color:#036;font-weight:bold">BACKWARD_JUMP</span>
        <span style="color:#080;font-weight:bold">if</span> cell_value.zero?
          skip_while(<span style="color:#036;font-weight:bold">BACKWARD_JUMP</span>)
        <span style="color:#080;font-weight:bold">else</span>
          jump_back
        <span style="color:#080;font-weight:bold">end</span>
      <span style="color:#080;font-weight:bold">end</span>

      <span style="color:#036;font-weight:bold">OPERATIONS</span>[current_char]
    <span style="color:#080;font-weight:bold">end</span>

    <span style="color:#777"># ... lots of private methods are back, but now fine-tuned.</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>The old <code>Interpreter</code> object and <code>Tape</code> object were also merged together, forming a single object I ended up calling <code>Evaluator</code>. The job of the <code>Evaluator</code> object is to take a stream of operations provided by the newly defined <code>Interpreter</code> object and then execute them against a Turing Machine like data structure. In essence, the <code>Evaluator</code> object is nothing more than the original <code>Tape</code> object I implemented along with a few extra methods which account for the things the original <code>Interpreter</code> object was meant to do:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">module</span> <span style="color:#B06;font-weight:bold">TuringTarpit</span>
  <span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Evaluator</span> 
    <span style="color:#080;font-weight:bold">def</span> <span style="color:#069">self</span>.<span style="color:#06B;font-weight:bold">run</span>(interpreter)
      evaluator = new

      loop <span style="color:#080;font-weight:bold">do</span>
        <span style="color:#080;font-weight:bold">if</span> operation = interpreter.next_operation(evaluator.cell_value)
          evaluator.send(operation)
        <span style="color:#080;font-weight:bold">end</span>
      <span style="color:#080;font-weight:bold">end</span>
    <span style="color:#080;font-weight:bold">end</span>

    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">output_cell_value</span>
      putc(cell_value)
    <span style="color:#080;font-weight:bold">end</span>

    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">input_cell_value</span>
      value = <span style="color:#d70">$stdin</span>.getch.ord
      <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">if</span> value.zero?

      <span style="color:#069">self</span>.cell_value = value
    <span style="color:#080;font-weight:bold">end</span>

    <span style="color:#777"># other methods same as original Tape methods</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></div>
</div>
</div>

<p>I had mixed feelings about recombining these objects, because to some extent it felt like a step backwards to me. In particular, I think this refactoring resulted in some minor violations of the <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">Single Responsibility Principle</a>, and increased the overall coupling of the system somewhat. However, the independence of the four different objects the system previously consisted of seemed artificial at best. To the extent that they could be changed easily or swapped out for one another, I could not think of a single practical reason why I’d actually want that kind of flexibility. In this particular situation it turned out that recombining the objects greatly reduced their communications overhead, and so was worth the loss in generality.</p>

<h3 id="epilogue-sending-the-ship-out-to-sea">Epilogue. Sending the ship out to sea</h3>

<p>I was really tempted to keep noodling on the design of this project, because even in my final version of the code I still felt that I could have done better. But at a certain point I decided that I could end up getting caught in this trap forever, and the only way to free myself from it was to wrap up my work and just ship the damn thing. This ultimately meant that I had to take care of several chores that neither I nor the various participants in this challenge bothered to work on earlier:</p>

<ul>
  <li>
    <p>I added a <a href="https://github.com/elm-city-craftworks/turing_tarpit/blob/act3/test/integration/evaluator_test.rb">set of integration tests</a> which ran the <code>Evaluator</code> against a couple sample Brainfuck programs to make sure we had some decent end-to-end testing support. Found a couple bugs that way.</p>
  </li>
  <li>
    <p>I set up and ran <a href="https://github.com/colszowka/simplecov">simplecov</a> to check whether my tests were at least <em>running</em> all the implementation code, and ended up spotting a faulty test which wasn’t actually getting run.</p>
  </li>
  <li>
    <p>I added a <a href="https://github.com/elm-city-craftworks/turing_tarpit/blob/act3/bin/turing_tarpit">bin/turing_tarpit</a> file so that you can execute Brainfuck programs without building a Ruby shim first. </p>
  </li>
  <li>
    <p>Did the usual gemspec + Gemfile dance and pushed a 1.0.0 gem to rubygems.org. Typically I’d call a project in its early stages a 0.1.0 release, but I honestly don’t see myself working on this much more so I might as well call it ‘production ready’.</p>
  </li>
</ul>

<p>After I wrapped up all these chores, I decided to go back and check out what my <a href="https://github.com/seattlerb/flog">flog</a> complexity scores were for each stage in this process. It turns out that the final version was the least complex, with the lowest overall score, lowest average score, and lowest top-score by method. The original implementation came in second place, and the other two iterations were in a distant third and fourth place. While that gave me some reassurances, it doesn’t mean much except for that Flog seems to really hate external method calls.</p>

<h3 id="reflections">Reflections</h3>

<p>This has been one of my favorite articles to write for Practicing Ruby so far. It forced me to look at the refactoring process in a much more introspective way than I have typically done in the past, and gave me a chance to interact with some of our awesome readers. I do think it ended up raising more questions and challenges in my mind than it did give me answers and reassurances, but I suppose that’s a sign that learning happened.</p>

<p>While I found it very hard to summarize the refactoring lifecycle for this project, my hope is that I’ve at least given you a glimpse of the spiral staircase metaphor I chose to name this article after. If it didn’t end up making you feel too dizzy, I’d love to hear your thoughts about this exercise as well as what your own process is like when it comes to refactoring code.</p>

  </div>
</body>
</html>

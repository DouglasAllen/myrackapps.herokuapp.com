<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/>
      <!--<link rel="stylesheet" type="text/css" href="stylesheets/default.css">-->
      <!--<!--<link href="stylesheets/d.css" rel="stylesheet" type="text/css" />-->
      <!--<link href="stylesheets/fixes.css" rel="stylesheet" type="text/css" />-->
      <!--<link href="stylesheets/main.css" rel="stylesheet" type="text/css" />-->
      <!--<link href="stylesheets/reset.css" rel="stylesheet" type="text/css" />-->
      <!--<link href="stylesheets/print.css" rel="stylesheet" type="text/css" />-->
      <!--<link href="stylesheets/styles.css" rel="stylesheet" type="text/css" />-->
      <!--<link href="stylesheets/style.css" rel="stylesheet" type="text/css" />-->

     <style>
/* Site */
body {
      font-family: Verdana, Lucida Grande, Arial, Helvetica, sans-serif;
      font-size: 16px;
      line-height: 18px;
      padding-top: 10px;
      padding-bottom: 10px;
      background-color: white;
      padding: 30px;
      color: #333;
      border: 1px solid #aaa;
      max-width: 900px;
      margin: 20px auto;	
      background: #fff url(/images/topbluefade.gif) repeat-x center top;	
}

    body > *:first-child {
      margin-top: 0 !important;
    }

    body > *:last-child {
      margin-bottom: 0 !important;
    }

    a {
      color: #4183C4;
      text-decoration: none;
    }

    a.absent {
      color: #cc0000;
    }

    a.anchor {
      display: block;
      padding-left: 30px;
      margin-left: -30px;
      cursor: pointer;
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
    }

    h1, h2, h3, h4, h5, h6 {
      margin: 20px 0 10px;
      padding: 0;
      font-weight: bold;
      -webkit-font-smoothing: antialiased;
      cursor: text;
      position: relative;
    }

    h2:first-child, h1:first-child, h1:first-child + h2, h3:first-child, h4:first-child, h5:first-child, h6:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
      text-decoration: none;
    }

    h1 tt, h1 code {
      font-size: inherit;
    }

    h2 tt, h2 code {
      font-size: inherit;
    }

    h3 tt, h3 code {
      font-size: inherit;
    }

    h4 tt, h4 code {
      font-size: inherit;
    }

    h5 tt, h5 code {
      font-size: inherit;
    }

    h6 tt, h6 code {
      font-size: inherit;
    }

    h1 {
      font-size: 28px;
      color: black;
    }

    h2 {
      font-size: 24px;
      border-bottom: 1px solid #cccccc;
      color: black;
    }

    h3 {
      font-size: 18px;
    }

    h4 {
      font-size: 16px;
    }

    h5 {
      font-size: 14px;
    }

    h6 {
      color: #777777;
      font-size: 14px;
    }

    p, blockquote, ul, ol, dl, li, table, pre {
      margin: 3px 0;
    }

    hr {
      background: transparent url("http://tinyurl.com/bq5kskr") repeat-x 0 0;
      border: 0 none;
      color: #cccccc;
      height: 4px;
      padding: 0;
    }

    body > h2:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    body > h1:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    body > h1:first-child + h2 {
      margin-top: 0;
      padding-top: 0;
    }

    body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
      margin-top: 0;
      padding-top: 0;
    }

    h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
      margin-top: 0;
    }

    li p.first {
      display: inline-block;
    }

    ul, ol {
      padding-left: 30px;
    }

    ul :first-child, ol :first-child {
      margin-top: 0;
    }

    ul :last-child, ol :last-child {
      margin-bottom: 0;
    }

    dl {
      padding: 0;
    }

    dl dt {
      font-size: 14px;
      font-weight: bold;
      font-style: italic;
      padding: 0;
      margin: 15px 0 5px;
    }

    dl dt:first-child {
      padding: 0;
    }

    dl dt > :first-child {
      margin-top: 0;
    }

    dl dt > :last-child {
      margin-bottom: 0;
    }

    dl dd {
      margin: 0 0 15px;
      padding: 0 15px;
    }

    dl dd > :first-child {
      margin-top: 0;
    }

    dl dd > :last-child {
      margin-bottom: 0;
    }

    blockquote {
      border-left: 4px solid #dddddd;
      padding: 0 15px;
      color: #777777;
    }

    blockquote > :first-child {
      margin-top: 0;
    }

    blockquote > :last-child {
      margin-bottom: 0;
    }

    table {
      padding: 0;
    }
    table tr {
      border-top: 1px solid #cccccc;
      background-color: white;
      margin: 0;
      padding: 0;
    }

    table tr:nth-child(2n) {
      background-color: #f8f8f8;
    }

    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      text-align: left;
      margin: 0;
      padding: 6px 13px;
    }

    table tr td {
      border: 1px solid #cccccc;
      text-align: left;
      margin: 0;
      padding: 6px 13px;
    }

    table tr th :first-child, table tr td :first-child {
      margin-top: 0;
    }

    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0;
    }

    img {
      max-width: 100%;
    }

    span.frame {
      display: block;
      overflow: hidden;
    }

    span.frame > span {
      border: 1px solid #dddddd;
      display: block;
      float: left;
      overflow: hidden;
      margin: 13px 0 0;
      padding: 7px;
      width: auto;
    }

    span.frame span img {
      display: block;
      float: left;
    }

    span.frame span span {
      clear: both;
      color: #333333;
      display: block;
      padding: 5px 0 0;
    }

    span.align-center {
      display: block;
      overflow: hidden;
      clear: both;
    }

    span.align-center > span {
      display: block;
      overflow: hidden;
      margin: 13px auto 0;
      text-align: center;
    }

    span.align-center span img {
      margin: 0 auto;
      text-align: center;
    }

    span.align-right {
      display: block;
      overflow: hidden;
      clear: both;
    }

    span.align-right > span {
      display: block;
      overflow: hidden;
      margin: 13px 0 0;
      text-align: right;
    }

    span.align-right span img {
      margin: 0;
      text-align: right;
    }

    span.float-left {
      display: block;
      margin-right: 13px;
      overflow: hidden;
      float: left;
    }

    span.float-left span {
      margin: 13px 0 0;
    }

    span.float-right {
      display: block;
      margin-left: 13px;
      overflow: hidden;
      float: right;
    }

    span.float-right > span {
      display: block;
      overflow: hidden;
      margin: 13px auto 0;
      text-align: right;
    }

    code, tt {
      font-family: "Lucida Console", "Courier New", courier;
      font-size: 12px;
      margin: 0 2px;
      padding: 3px 5px;
      white-space: nowrap;
      border: 1px solid #eaeaea;
      background-color: #f8f8f8;
      border-radius: 3px;
    }

    pre code {
      margin: 0;
      padding: 0;
      white-space: pre;
      border: none;
      background: transparent;
    }

    .highlight pre {
      background-color: #f8f8f8;
      border: 1px solid #cccccc;
      font-size: 13px;
      line-height: 19px;
      overflow: auto;
      padding: 6px 10px;
      border-radius: 3px;
    }

    pre {
      background-color: #f8f8f8;
      border: 1px solid #cccccc;
      font-size: 13px;
      line-height: 19px;
      overflow: auto;
      padding: 6px 10px;
      border-radius: 3px;
    }

    pre code, pre tt {
      background-color: transparent;
      border: none;
    }

    span.line-numbers {
      margin-right: 10px;
    }

    img.logo {
      display: block;
      margin: 10px auto;
    }

    h1.logo {
      text-align: center;
      font-size: 40px;
    }
a img {
	border: none;
}
a.nohover {
	background-color: transparent !important;
}
a.align-right {
	float: right;
	margin: 0px 0px 0px 10px;
}
a.align-right img {
	display: block;
}
a.align-center {
	display: inline-block;
	margin: 0px 5px;
}
a.align-center img {
	display: block;
}
img.bordered {
	background-color: #fff;
	border: 1px solid #CCC;
	padding: 1px;
}
img.align-right {
	float: right;
	margin: 0px 0px 0px 10px;
}
span.highlight {
	background-color: #ffc;
}
div.section {
	margin: 0px auto;
	overflow: hidden;
	width: 700px;
}
div.section h2 {
	color: #000;
	float: left;
	font-family: Georgia;
	font-size: 28px;
	font-weight: normal;
	line-height: 120%;
	margin: 0px 0px 20px 0px;
	text-align: right;
	width: 200px;
}
div.section h3 {
	color: #900;
	font-family: Georgia;
	font-size: 18px;
	margin: 0px 0px 0px 250px;
	line-height: 140%;
}
div.section h3.pull-left {
	font-size: 20px;
	font-weight: normal;
	line-height: 120%;
	color: #900;
	float: left;
	margin: 0px 0px 10px 0px;
	width: 200px;
	text-align: right;
}
div.section p {
	font-family: Georgia;
	font-size: 18px;
	line-height: 140%;
	margin: 0px 0px 25px 250px;
	width: 450px;
}
div.section h2.small {
	font-size: 20px;
}
div.section p.small {
	font-size: 14px;
}
div.section blockquote {
	margin: 0px 0px 25px 250px;
	width: 450px;
}
div.section blockquote p {
	font-family: Courier New, Courier, mono;
	font-size: 16px;
	font-weight: bold;
	line-height: 140%;
	margin: 0px 25px;
	width: auto;
}
div.section p.more {
	font-size: 12px;
	text-align: center;
}
div.section p.centered {
	text-align: center;
}
div.section p.download,
div.section p.credit {
	font-size: 14px;
}
div.section p.footnote,
div.section p.sponsorship {
	font-size: 12px;
}
div.section img.biopic {
	background-color: #fff;
	border: 2px solid #ccc;
	padding: 2px;
	float: left;
	margin: 0px 0px 10px 40px;
}
div.section a.screencast {
	background-color: transparent !important;
	float: left;
	clear: left;
	margin: 0px 0px 25px 25px;
}
div.section a.screencast img {
	display: block;
	background-color: #fff;
	border: 2px solid #ccc;
	padding: 2px;
}
div.section ul.grid {
	list-style: none;
	margin: 0px 0px 15px 280px;
	padding: 0px;
	overflow: hidden;
	width: 420px;
}
div.section ul.grid li {
	float: left;
	margin: 0px 0px 0px 0px;
	height: 160px;
	width: 200px;
}
div.section ul.grid li a {
	background-color: transparent !important;
	display: block;
	margin: 0px 0px 5px 0px;
}
div.section ul.grid li img {
	display: block;
	border: 1px solid #ccc;
	padding: 1px;
}
div.section ul.grid li p {
	font-size: 10px;
	font-family: inherit;
	margin: 0px;
	width: auto;
}
div.section ul.grid li p a {
	display: inline;
}
div.section ul.grid li p a:hover {
	background-color: #f4dda6 !important;
}
div.section div.video {
	margin: 0px 0px 25px 250px;
	width: 450px;
}
div.section ul.links {
	list-style: none;
	float: left;
	clear: left;
	text-align: right;
	width: 200px;
	padding: 0px;
	margin: 0px 0px 20px 0px;
	font-family: Georgia;
	font-size: 14px;
	line-height: 140%;
	overflow: hidden;
}
div.section ul.links li {
	float: right;
	clear: right;
}
div.section ul.links li.rss {
	background: url(/images/rss.png) no-repeat 0px 1px;
	padding: 0px 0px 0px 22px;
}
div.section code {
	font-family: Courier New, Courier, mono;
	font-size: 16px;
	font-weight: bold;
}
#navigation {
	width: 726px;
	margin: 15px auto 10px;
	font-size: 10px;
	line-height: 12px;
	text-align: center;
}
#navigation a {
	color: #000;
	font-weight: bold;
	font-size: 11px;
	text-decoration: underline;
}
#navigation a:hover {
	background-color: #000;
	color: #fff;
	text-decoration: none;
}
#article {
	padding: 0px 0px 20px 0px;
}
#article header {
	background: url(/images/rails.png) no-repeat left top;
	margin: 50px auto 32px;
	width: 606px;
	padding-left: 100px;
	text-align: center;
}
#article header h1 {
	margin: 0 auto 12px;
  font-family: "expressway",sans-serif;
  font-style: normal;
  font-weight: 700;
	font-size: 38px;
  line-height: 30px;
  color: #000000;
}
#article header h2 {
	margin: 0 auto;
  font-family: "expressway",sans-serif;
  font-style: normal;
  font-weight: 400;
	font-size: 21px;
	line-height: 24px;
	color: #999999;
}
#article p a,
#article ol a,
#article ul a {
	color: #369;
}
#article p a:hover,
#article ol a:hover,
#article ul a:hover {
	background-color: #f4dda6;
	text-decoration: none;
}
#article hr.rule {
	border: 0px;
	color: #bbb;
	background-color: #bbb;
	height: 1px;
	width: 670px;
	margin: 0px auto 25px;
}
#article p.missing {
	color: #000;
	font-family: Georgia;
	font-size: 28px;
	font-weight: normal;
	line-height: 120%;
	margin: 0px auto;
	text-align: center;
	width: 700px;
}
#footer {
	color: #666;
	font-size: 11px;
	margin: 0px auto;
	padding: 0px 0px 44px 0px;
	text-align: center;
	width: 726px;
}
#footer p {
	margin: 12px 0px;
}
#footer p a {
	color: #000;
}
#footer p a:hover {
	background-color: #333;
	color: #fff;
	text-decoration: none;
}
#sponsored_by {
	margin: 17px 0px !important;
}
#sponsored_by a:hover {
	background-color: transparent !important;
}
#sponsored_by a img {
	vertical-align: -7px;
}

/* Overview */
#announce {
	background-color: #981a21;
	color: #fff;
	font-size: 11px;
	line-height: 13px;
	margin: 0px;
	padding: 5px 0px;
	text-align: center;
}
#announce a {
	color: #fff !important;
	text-decoration: underline;
}
#announce a:hover {
	background-color: #000 !important;
	text-decoration: none;
}
#slivers {
	background: url(/images/herobackground.gif) repeat-x left top;
	border-top: 2px solid #F6E69F;
	border-bottom: 2px solid #F6E69F;
	padding: 10px;
}
#slivers ul {
	list-style: none;
	margin: 0px auto;
	padding: 0px;
	overflow: hidden;
	width: 792px;
}
#slivers ul li {
	float: left;
	margin: 0px 24px;
	width: 150px;
}
#slivers ul li h2 {
	color: #0e3062;
	font-family: Georgia;
	font-size: 22px;
	line-height: 24px;
	font-weight: normal;
	margin: 0px 0px 10px 0px;
	text-align: center;
}
#slivers ul li img {
	display: block;
	margin: 0px auto 5px;
}
#slivers ul li p {
	margin: 0px;
	text-align: center;
}
#slivers ul li p a {
	color: #000;
	font-size: 10px;
}
#slivers ul li p a:hover {
	background-color: #000;
	color: #fff;
	text-decoration: none;
}

#slideshow {
	font-family: Georgia;
	font-size: 16px;
	height: 132px;
	line-height: 140%;
	margin: 0px auto 30px;
	text-align: center;
	width: 700px;
	padding: 30px 0px 0px 0px;
	position: relative;
}
#slideshow blockquote {
	margin: 0px;
	position: absolute;
	width: 700px;
}
#slideshow blockquote p {
	margin: 0px;
}
#slideshow blockquote p cite {
	font-size: 14px;
	color: #464242;
}
#slideshow p.more {
	font-size: 14px;
	font-style: italic;
	margin: 0px;
	position: absolute;
	bottom: 0px;
	width: 700px;
}
#slideshow p.more a {
	color: #464242;
}
#slideshow p.more a:hover {
	background-color: #000;
	text-decoration: none;
}
#used_by ul {
	list-style: none;
	margin: 0px 0px 0px 280px;
	padding: 0px;
	overflow: hidden;
}
#used_by ul li {
	float: left;
	margin: 0px 0px 20px 0px;
	width: 209px;
}
#used_by ul li img {
	display: block;
	margin: 0px 0px 5px 0px;
}
#used_by ul li p {
	font-size: 10px;
	font-family: inherit;
	margin: 0px;
	width: auto;
}
/* Applications */
#applications {
	list-style: none;
	margin: 0px auto;
	padding: 0px 0px 0px 110px;
	overflow: hidden;
	width: 700px;
}
#applications li {
	float: left;
	width: 200px;
	margin: 0px 0px 20px 0px;
}
#applications li a {
	display: block;
	margin: 0px 0px 5px 0px;
	background-color: transparent !important;
}
#applications li a img {
	background-color: #fff;
	border: 1px solid #CCC;
	padding: 1px;
	display: block;
}
#applications li p {
	font-size: 10px;
	margin: 0px;
}
#applications li p a {
	display: inline;
}
#applications li p a:hover {
	background-color: #f4dda6 !important;
}
/* Quotes */
#article.quotes blockquote {
	font-family: Georgia;
	font-size: 18px;
	line-height: 140%;
	margin: 0px auto 25px;
	text-align: center;
	width: 700px;
	padding: 0px;
	position: relative;
}
#article.quotes blockquote p {
	margin: 0px;
}
#article.quotes blockquote p cite {
	font-size: 14px;
	color: #a69e8a;
}
/* Security Policy */
#article.security {
	margin: 50px auto 30px;
	width: 700px;
}
#article.security h2 {
	font-weight: bold;
	text-transform: uppercase;
	font-size: 20px;
	font-family: Arial, Helvetica, sans-serif;
	text-align: center;
	margin: 40px 0px 15px 0px;
}
#article.security h3 {
	color: #900;
	font-family: Georgia;
	font-size: 18px;
	margin: 0;
	line-height: 140%;
}
#article.security p,
#article.security ol {
	font-family: Georgia;
	font-size: 18px;
	line-height: 140%;
	margin: 0px 0px 25px 0px;
}
#article.security ol li {
	margin: 0px 0px 10px 0px;
}

     </style>
  </head>
  <body>
    <div id="containter">          
      <h1 id="you-dont-know-js-async--performance">You Don’t Know JS: Async &amp; Performance</h1>
<p># Appendix B: Advanced Async Patterns</p>

<p>Appendix A introduced the <em>asynquence</em> library for sequence-oriented async flow control, primarily based on Promises and generators.</p>

<p>Now we’ll explore other advanced asynchronous patterns built on top of that existing understanding and functionality, and see how <em>asynquence</em> makes those sophisticated async techniques easy to mix and match in our programs without needing lots of separate libraries.</p>

<h2 id="iterable-sequences">Iterable Sequences</h2>

<p>We introduced <em>asynquence</em>’s iterable sequences in the previous appendix, but we want to revisit them in more detail.</p>

<p>To refresh, recall:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> domready = ASQ.iterable();

<span style="color:#777">// ..</span>

domready.val( <span style="color:#080;font-weight:bold">function</span>(){
        <span style="color:#777">// DOM is ready</span>
} );

<span style="color:#777">// ..</span>

document.addEventListener( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">DOMContentLoaded</span><span style="color:#710">&quot;</span></span>, domready.next );
</pre></div>
</div>
</div>

<p>Now, let’s define a sequence of multiple steps as an iterable sequence:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> steps = ASQ.iterable();

steps
.then( <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">STEP1</span>(x){
        <span style="color:#080;font-weight:bold">return</span> x * <span style="color:#00D">2</span>;
} )
.steps( <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">STEP2</span>(x){
        <span style="color:#080;font-weight:bold">return</span> x + <span style="color:#00D">3</span>;
} )
.steps( <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">STEP3</span>(x){
        <span style="color:#080;font-weight:bold">return</span> x * <span style="color:#00D">4</span>;
} );

steps.next( <span style="color:#00D">8</span> ).value;        <span style="color:#777">// 16</span>
steps.next( <span style="color:#00D">16</span> ).value;        <span style="color:#777">// 19</span>
steps.next( <span style="color:#00D">19</span> ).value;        <span style="color:#777">// 76</span>
steps.next().done;                <span style="color:#777">// true</span>
</pre></div>
</div>
</div>

<p>As you can see, an iterable sequence is a standard-compliant <em>iterator</em> (see Chapter 4). So, it can be iterated with an ES6 <code>for..of</code> loop, just like a generator (or any other <em>iterable</em>) can:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> steps = ASQ.iterable();

steps
.then( <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">STEP1</span>(){ <span style="color:#080;font-weight:bold">return</span> <span style="color:#00D">2</span>; } )
.then( <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">STEP2</span>(){ <span style="color:#080;font-weight:bold">return</span> <span style="color:#00D">4</span>; } )
.then( <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">STEP3</span>(){ <span style="color:#080;font-weight:bold">return</span> <span style="color:#00D">6</span>; } )
.then( <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">STEP4</span>(){ <span style="color:#080;font-weight:bold">return</span> <span style="color:#00D">8</span>; } )
.then( <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">STEP5</span>(){ <span style="color:#080;font-weight:bold">return</span> <span style="color:#00D">10</span>; } );

<span style="color:#080;font-weight:bold">for</span> (<span style="color:#080;font-weight:bold">var</span> v of steps) {
        console.log( v );
}
<span style="color:#777">// 2 4 6 8 10</span>
</pre></div>
</div>
</div>

<p>Beyond the event triggering example shown in the previous appendix, iterable sequences are interesting because in essence they can be seen as a stand-in for generators or Promise chains, but with even more flexibility.</p>

<p>Consider a multiple Ajax request example – we’ve seen the same scenario in Chapters 3 and 4, both as a Promise chain and as a generator, respectively – expressed as an iterable sequence:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#777">// sequence-aware ajax</span>
<span style="color:#080;font-weight:bold">var</span> request = ASQ.wrap( ajax );

ASQ( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">http://some.url.1</span><span style="color:#710">&quot;</span></span> )
.runner(
        ASQ.iterable()

        .then( <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">STEP1</span>(token){
                <span style="color:#080;font-weight:bold">var</span> url = token.messages[<span style="color:#00D">0</span>];
                <span style="color:#080;font-weight:bold">return</span> request( url );
        } )

        .then( <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">STEP2</span>(resp){
                <span style="color:#080;font-weight:bold">return</span> ASQ().gate(
                        request( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">http://some.url.2/?v=</span><span style="color:#710">&quot;</span></span> + resp ),
                        request( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">http://some.url.3/?v=</span><span style="color:#710">&quot;</span></span> + resp )
                );
        } )

        .then( <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">STEP3</span>(r1,r2){ <span style="color:#080;font-weight:bold">return</span> r1 + r2; } )
)
.val( <span style="color:#080;font-weight:bold">function</span>(msg){
        console.log( msg );
} );
</pre></div>
</div>
</div>

<p>The iterable sequence expresses a sequential series of (sync or async) steps that looks awfully similar to a Promise chain – in other words, it’s much cleaner looking than just plain nested callbacks, but not quite as nice as the <code>yield</code>-based sequential syntax of generators.</p>

<p>But we pass the iterable sequence into <code>ASQ#runner(..)</code>, which runs it to completion the same as if it was a generator. The fact that an iterable sequence behaves essentially the same as a generator is notable for a couple of reasons.</p>

<p>First, iterable sequences are kind of a pre-ES6 equivalent to a certain subset of ES6 generators, which means you can either author them directly (to run anywhere), or you can author ES6 generators and transpile/convert them to iterable sequences (or Promise chains for that matter!).</p>

<p>Thinking of an async-run-to-completion generator as just syntactic sugar for a Promise chain is an important recognition of their isomorphic relationship.</p>

<p>Before we move on, we should note that the previous snippet could have been expressed in <em>asynquence</em> as:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>ASQ( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">http://some.url.1</span><span style="color:#710">&quot;</span></span> )
.seq( <span style="color:#777">/*STEP 1*/</span> request )
.seq( <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">STEP2</span>(resp){
        <span style="color:#080;font-weight:bold">return</span> ASQ().gate(
                request( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">http://some.url.2/?v=</span><span style="color:#710">&quot;</span></span> + resp ),
                request( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">http://some.url.3/?v=</span><span style="color:#710">&quot;</span></span> + resp )
        );
} )
.val( <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">STEP3</span>(r1,r2){ <span style="color:#080;font-weight:bold">return</span> r1 + r2; } )
.val( <span style="color:#080;font-weight:bold">function</span>(msg){
        console.log( msg );
} );
</pre></div>
</div>
</div>

<p>Moreover, step 2 could have even been expressed as:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>.gate(
        <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">STEP2a</span>(done,resp) {
                request( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">http://some.url.2/?v=</span><span style="color:#710">&quot;</span></span> + resp )
                .pipe( done );
        },
        <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">STEP2b</span>(done,resp) {
                request( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">http://some.url.3/?v=</span><span style="color:#710">&quot;</span></span> + resp )
                .pipe( done );
        }
)
</pre></div>
</div>
</div>

<p>So, why would we go to the trouble of expressing our flow control as an iterable sequence in a <code>ASQ#runner(..)</code> step, when it seems like a simpler/flatter <em>asyquence</em> chain does the job well?</p>

<p>Because the iterable sequence form has an important trick up its sleeve that gives us more capability. Read on.</p>

<h3 id="extending-iterable-sequences">Extending Iterable Sequences</h3>

<p>Generators, normal <em>asynquence</em> sequences, and Promise chains, are all <strong>eagerly evaluated</strong> – whatever flow control is expressed initially <em>is</em> the fixed flow that will be followed.</p>

<p>However, iterable sequences are <strong>lazily evaluated</strong>, which means that during execution of the iterable sequence, you can extend the sequence with more steps if desired.</p>

<p><strong>Note:</strong> You can only append to the end of an iterable sequence, not inject into the middle of the sequence.</p>

<p>Let’s first look at a simpler (synchronous) example of that capability to get familiar with it:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">function</span> <span style="color:#080;font-weight:bold">double</span>(x) {
        x *= <span style="color:#00D">2</span>;

        <span style="color:#777">// should we keep extending?</span>
        <span style="color:#080;font-weight:bold">if</span> (x &lt; <span style="color:#00D">500</span>) {
                isq.then( <span style="color:#080;font-weight:bold">double</span> );
        }

        <span style="color:#080;font-weight:bold">return</span> x;
}

<span style="color:#777">// setup single-step iterable sequence</span>
<span style="color:#080;font-weight:bold">var</span> isq = ASQ.iterable().then( <span style="color:#080;font-weight:bold">double</span> );

<span style="color:#080;font-weight:bold">for</span> (<span style="color:#080;font-weight:bold">var</span> v = <span style="color:#00D">10</span>, ret;
        (ret = isq.next( v )) &amp;&amp; !ret.done;
) {
        v = ret.value;
        console.log( v );
}
</pre></div>
</div>
</div>

<p>The iterable sequence starts out with only one defined step (<code>isq.then(double)</code>), but the sequence keeps extending itself under certain conditions (<code>x &lt; 500</code>). Both <em>asynquence</em> sequences and Promise chains technically <em>can</em> do something similar, but we’ll see in a little bit why their capability is insufficient.</p>

<p>Though this example is rather trivial and could otherwise be expressed with a <code>while</code> loop in a generator, we’ll consider more sophisticated cases.</p>

<p>For instance, you could examine the response from an Ajax request and if it indicates that more data is needed, you conditionally insert more steps into the iterable sequence to make the additional request(s). Or you could conditionally add a value-formatting step to the end of your Ajax handling.</p>

<p>Consider:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> steps = ASQ.iterable()

.then( <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">STEP1</span>(token){
        <span style="color:#080;font-weight:bold">var</span> url = token.messages[<span style="color:#00D">0</span>].url;

        <span style="color:#777">// was an additional formatting step provided?</span>
        <span style="color:#080;font-weight:bold">if</span> (token.messages[<span style="color:#00D">0</span>].format) {
                steps.then( token.messages[<span style="color:#00D">0</span>].format );
        }

        <span style="color:#080;font-weight:bold">return</span> request( url );
} )

.then( <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">STEP2</span>(resp){
        <span style="color:#777">// add another Ajax request to the sequence?</span>
        <span style="color:#080;font-weight:bold">if</span> (<span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#808">x1</span><span style="color:#404">/</span></span>.test( resp )) {
                steps.then( <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">STEP5</span>(text){
                        <span style="color:#080;font-weight:bold">return</span> request(
                                <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">http://some.url.4/?v=</span><span style="color:#710">&quot;</span></span> + text
                        );
                } );
        }

        <span style="color:#080;font-weight:bold">return</span> ASQ().gate(
                request( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">http://some.url.2/?v=</span><span style="color:#710">&quot;</span></span> + resp ),
                request( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">http://some.url.3/?v=</span><span style="color:#710">&quot;</span></span> + resp )
        );
} )

.then( <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">STEP3</span>(r1,r2){ <span style="color:#080;font-weight:bold">return</span> r1 + r2; } );
</pre></div>
</div>
</div>

<p>You can see in two different places where we conditionally extend <code>steps</code> with <code>steps.then(..)</code>. And to run this <code>steps</code> iterable sequence, we just wire it into our main program flow with an <em>asynquence</em> sequence (called <code>main</code> here) using <code>ASQ#runner(..)</code>:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> main = ASQ( {
        <span style="color:#606">url</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">http://some.url.1</span><span style="color:#710">&quot;</span></span>,
        <span style="color:#06B;font-weight:bold">format</span>: <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">STEP4</span>(text){
                <span style="color:#080;font-weight:bold">return</span> text.toUpperCase();
        }
} )
.runner( steps )
.val( <span style="color:#080;font-weight:bold">function</span>(msg){
        console.log( msg );
} );
</pre></div>
</div>
</div>

<p>Can the flexibility (conditional behavior) of the <code>steps</code> iterable sequence be expressed with a generator? Kind of, but we have to rearrange the logic in a slightly awkward way:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">function</span> *steps(token) {
        <span style="color:#777">// **STEP 1**</span>
        <span style="color:#080;font-weight:bold">var</span> resp = yield request( token.messages[<span style="color:#00D">0</span>].url );

        <span style="color:#777">// **STEP 2**</span>
        <span style="color:#080;font-weight:bold">var</span> rvals = yield ASQ().gate(
                request( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">http://some.url.2/?v=</span><span style="color:#710">&quot;</span></span> + resp ),
                request( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">http://some.url.3/?v=</span><span style="color:#710">&quot;</span></span> + resp )
        );

        <span style="color:#777">// **STEP 3**</span>
        <span style="color:#080;font-weight:bold">var</span> text = rvals[<span style="color:#00D">0</span>] + rvals[<span style="color:#00D">1</span>];

        <span style="color:#777">// **STEP 4**</span>
        <span style="color:#777">// was an additional formatting step provided?</span>
        <span style="color:#080;font-weight:bold">if</span> (token.messages[<span style="color:#00D">0</span>].format) {
                text = yield token.messages[<span style="color:#00D">0</span>].format( text );
        }

        <span style="color:#777">// **STEP 5**</span>
        <span style="color:#777">// need another Ajax request added to the sequence?</span>
        <span style="color:#080;font-weight:bold">if</span> (<span style="background-color:hsla(300,100%,50%,0.06)"><span style="color:#404">/</span><span style="color:#808">foobar</span><span style="color:#404">/</span></span>.test( resp )) {
                text = yield request(
                        <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">http://some.url.4/?v=</span><span style="color:#710">&quot;</span></span> + text
                );
        }

        <span style="color:#080;font-weight:bold">return</span> text;
}

<span style="color:#777">// note: `*steps()` can be run by the same `ASQ` sequence</span>
<span style="color:#777">// as `steps` was previously</span>
</pre></div>
</div>
</div>

<p>Setting aside the already identified benefits of the sequential, synchronous-looking syntax of generators (see Chapter 4), the <code>steps</code> logic had to be reordered in the <code>*steps()</code> generator form, to fake the dynamicism of the extendable iterable sequence <code>steps</code>.</p>

<p>What about expressing the functionality with Promises or sequences, though? You <em>can</em> do something like this:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> steps = something( .. )
.then( .. )
.then( <span style="color:#080;font-weight:bold">function</span>(..){
        <span style="color:#777">// ..</span>

        <span style="color:#777">// extending the chain, right?</span>
        steps = steps.then( .. );

        <span style="color:#777">// ..</span>
})
.then( .. );
</pre></div>
</div>
</div>

<p>The problem is subtle but important to grasp. So, consider trying to wire up our <code>steps</code> Promise chain into our main program flow – this time expressed with Promises instead of <em>asynquence</em>:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> main = Promise.resolve( {
        <span style="color:#606">url</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">http://some.url.1</span><span style="color:#710">&quot;</span></span>,
        <span style="color:#06B;font-weight:bold">format</span>: <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">STEP4</span>(text){
                <span style="color:#080;font-weight:bold">return</span> text.toUpperCase();
        }
} )
.then( <span style="color:#080;font-weight:bold">function</span>(..){
        <span style="color:#080;font-weight:bold">return</span> steps;                        <span style="color:#777">// hint!</span>
} )
.val( <span style="color:#080;font-weight:bold">function</span>(msg){
        console.log( msg );
} );
</pre></div>
</div>
</div>

<p>Can you spot the problem now? Look closely!</p>

<p>There’s a race condition for sequence steps ordering. When you <code>return steps</code>, at that moment <code>steps</code> <em>might</em> be the originally defined promise chain, or it might now point to the extended promise chain via the <code>steps = steps.then(..)</code> call, depending on what order things happen.</p>

<p>Here are the two possible outcomes:</p>

<ul>
  <li>If <code>steps</code> is still the original promise chain, once it’s later “extended” by <code>steps = steps.then(..)</code>, that extended promise on the end of the chain is <strong>not</strong> considered by the <code>main</code> flow, as it’s already tapped the <code>steps</code> chain. This is the unfortunately limiting <strong>eager evaluation</strong>.</li>
  <li>If <code>steps</code> is already the extended promise chain, it works as we expect in that the extended promise is what <code>main</code> taps.</li>
</ul>

<p>Other than the obvious fact that a race condition is intolerable, the first case is the concern; it illustrates <strong>eager evaluation</strong> of the promise chain. By contrast, we easily extended the iterable sequence without such issues, because iterable sequences are <strong>lazily evaluated</strong>.</p>

<p>The more dynamic you need your flow control, the more iterable sequences will shine.</p>

<p><strong>Tip:</strong> Check out more information and examples of iterable sequences on the <em>asynquence</em> site (https://github.com/getify/asynquence/blob/master/README.md#iterable-sequences).</p>

<h2 id="event-reactive">Event Reactive</h2>

<p>It should be obvious from (at least!) Chapter 3 that Promises are a very powerful tool in your async toolbox. But one thing that’s clearly lacking is in their capability to handle streams of events, as a Promise can only be resolved once. And frankly, this exact same weakness is true of plain <em>asynquence</em> sequences, as well.</p>

<p>Consider a scenario where you want to fire off a series of steps every time a certain event is fired. A single Promise or sequence cannot represent all occurrences of that event. So, you have to create a whole new Promise chain (or sequence) for <em>each</em> event occurrence, such as:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>listener.on( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">foobar</span><span style="color:#710">&quot;</span></span>, <span style="color:#080;font-weight:bold">function</span>(data){

        <span style="color:#777">// create a new event handling promise chain</span>
        <span style="color:#080;font-weight:bold">new</span> Promise( <span style="color:#080;font-weight:bold">function</span>(resolve,reject){
                <span style="color:#777">// ..</span>
        } )
        .then( .. )
        .then( .. );

} );
</pre></div>
</div>
</div>

<p>The base functionality we need is present in this approach, but it’s far from a desirable way to express our intended logic. There are two separate capabilities conflated in this paradigm: the event listening, and responding to the event; separation of concerns would implore us to separate out these capabilities.</p>

<p>The carefully observant reader will see this problem as somewhat symmetrical to the problems we detailed with callbacks in Chapter 2; it’s kind of an inversion of control problem.</p>

<p>Imagine uninverting this paradigm, like so:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> observable = listener.on( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">foobar</span><span style="color:#710">&quot;</span></span> );

<span style="color:#777">// later</span>
observable
.then( .. )
.then( .. );

<span style="color:#777">// elsewhere</span>
observable
.then( .. )
.then( .. );
</pre></div>
</div>
</div>

<p>The <code>observable</code> value is not exactly a Promise, but you can <em>observe</em> it much like you can observe a Promise, so it’s closely related. In fact, it can be observed many times, and it will send out notifications every time its event (<code>"foobar"</code>) occurs.</p>

<p><strong>Tip:</strong> This pattern I’ve just illustrated is a <strong>massive simplification</strong> of the concepts and motivations behind reactive programming (aka RP), which has been implemented/expounded upon by several great projects and languages. A variation on RP is functional reactive programming (FRP), which refers to applying functional programming techniques (immutability, referential integrity, etc.) to streams of data. “Reactive” refers to spreading this functionality out over time in response to events. The interested reader should consider studying “Reactive Observables” in the fantastic “Reactive Extensions” library (“RxJS” for JavaScript) by Microsoft (http://reactive-extensions.github.io/RxJS/); it’s much more sophisticated and powerful than I’ve just shown. Also, Andre Staltz has an excellent write-up (https://gist.github.com/staltz/868e7e9bc2a7b8c1f754) that pragmatically lays out RP in concrete examples.</p>

<h3 id="es7-observables">ES7 Observables</h3>

<p>At the time of this writing, there’s an early ES7 proposal for a new data type called “Observable” (https://github.com/jhusain/asyncgenerator#introducing-observable), which in spirit is similar to what we’ve laid out here, but is definitely more sophisticated.</p>

<p>The notion of this kind of Observable is that the way you “subscribe” to the events from a stream is to pass in a generator – actually the <em>iterator</em> is the interested party – whose <code>next(..)</code> method will be called for each event.</p>

<p>You could imagine it sort of like this:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#777">// `someEventStream` is a stream of events, like from</span>
<span style="color:#777">// mouse clicks, and the like.</span>

<span style="color:#080;font-weight:bold">var</span> observer = <span style="color:#080;font-weight:bold">new</span> Observer( someEventStream, <span style="color:#080;font-weight:bold">function</span>*(){
        <span style="color:#080;font-weight:bold">while</span> (<span style="color:#080;font-weight:bold">var</span> evt = yield) {
                console.log( evt );
        }
} );
</pre></div>
</div>
</div>

<p>The generator you pass in will <code>yield</code> pause the <code>while</code> loop waiting for the next event. The <em>iterator</em> attached to the generator instance will have its <code>next(..)</code> called each time <code>someEventStream</code> has a new event published, and so that event data will resume your generator/<em>iterator</em> with the <code>evt</code> data.</p>

<p>In the subscription to events functionality here, it’s the <em>iterator</em> part that matters, not the generator. So conceptually you could pass in practically any iterable, including <code>ASQ.iterable()</code> iterable sequences.</p>

<p>Interestingly, there are also proposed adapters to make it easy to construct Observables from certain types of streams, such as <code>fromEvent(..)</code> for DOM events. If you look at a suggested implementation of <code>fromEvent(..)</code> in the earlier linked ES7 proposal, it looks an awful lot like the <code>ASQ.react(..)</code> we’ll see in the next section.</p>

<p>Of course, these are all early proposals, so what shakes out may very well look/behave differently than shown here. But it’s exciting to see the early alignments of concepts across different libraries and language proposals!</p>

<h3 id="reactive-sequences">Reactive Sequences</h3>

<p>With that crazy brief summary of Observables (and F/RP) as our inspiration and motivation, I will now illustrate an adaptation of a small subset of “Reactive Observables,” which I call “Reactive Sequences.”</p>

<p>First, let’s start with how to create an Observable, using an <em>asynquence</em> plug-in utility called <code>react(..)</code>:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> observable = ASQ.react( <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">setup</span>(next){
        listener.on( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">foobar</span><span style="color:#710">&quot;</span></span>, next );
} );
</pre></div>
</div>
</div>

<p>Now, let’s see how to define a sequence that “reacts” – in F/RP, this is typically called “subscribing” – to that <code>observable</code>:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>observable
.seq( .. )
.then( .. )
.val( .. );
</pre></div>
</div>
</div>

<p>So, you just define the sequence by chaining off the Observable. That’s easy, huh?</p>

<p>In F/RP, the stream of events typically channels through a set of functional transforms, like <code>scan(..)</code>, <code>map(..)</code>, <code>reduce(..)</code>, and so on. With reactive sequences, each event channels through a new instance of the sequence. Let’s look at a more concrete example:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>ASQ.react( <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">setup</span>(next){
        document.getElementById( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">mybtn</span><span style="color:#710">&quot;</span></span> )
        .addEventListener( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">click</span><span style="color:#710">&quot;</span></span>, next, <span style="color:#069">false</span> );
} )
.seq( <span style="color:#080;font-weight:bold">function</span>(evt){
        <span style="color:#080;font-weight:bold">var</span> btnID = evt.target.id;
        <span style="color:#080;font-weight:bold">return</span> request(
                <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">http://some.url.1/?id=</span><span style="color:#710">&quot;</span></span> + btnID
        );
} )
.val( <span style="color:#080;font-weight:bold">function</span>(text){
        console.log( text );
} );
</pre></div>
</div>
</div>

<p>The “reactive” portion of the reactive sequence comes from assigning one or more event handlers to invoke the event trigger (calling <code>next(..)</code>).</p>

<p>The “sequence” portion of the reactive sequence is exactly like the sequences we’ve already explored: each step can be whatever asynchronous technique makes sense, from continuation callback to Promise to generator.</p>

<p>Once you set up a reactive sequence, it will continue to initiate instances of the sequence as long as the events keep firing. If you want to stop a reactive sequence, you can call <code>stop()</code>.</p>

<p>If a reactive sequence is <code>stop()</code>‘d, you likely want the event handler(s) to be unregistered as well; you can register a teardown handler for this purpose:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> sq = ASQ.react( <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">setup</span>(next,registerTeardown){
        <span style="color:#080;font-weight:bold">var</span> btn = document.getElementById( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">mybtn</span><span style="color:#710">&quot;</span></span> );

        btn.addEventListener( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">click</span><span style="color:#710">&quot;</span></span>, next, <span style="color:#069">false</span> );

        <span style="color:#777">// will be called once `sq.stop()` is called</span>
        registerTeardown( <span style="color:#080;font-weight:bold">function</span>(){
                btn.removeEventListener( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">click</span><span style="color:#710">&quot;</span></span>, next, <span style="color:#069">false</span> );
        } );
} )
.seq( .. )
.then( .. )
.val( .. );

<span style="color:#777">// later</span>
sq.stop();
</pre></div>
</div>
</div>

<p><strong>Note:</strong> The <code>this</code> binding reference inside the <code>setup(..)</code> handler is the same <code>sq</code> reactive sequence, so you can use the <code>this</code> reference to add to the reactive sequence definition, call methods like <code>stop()</code>, and so on.</p>

<p>Here’s an example from the Node.js world, using reactive sequences to handle incoming HTTP requests:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> server = http.createServer();
server.listen(<span style="color:#00D">8000</span>);

<span style="color:#777">// reactive observer</span>
<span style="color:#080;font-weight:bold">var</span> request = ASQ.react( <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">setup</span>(next,registerTeardown){
        server.addListener( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">request</span><span style="color:#710">&quot;</span></span>, next );
        server.addListener( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">close</span><span style="color:#710">&quot;</span></span>, <span style="color:#950">this</span>.stop );

        registerTeardown( <span style="color:#080;font-weight:bold">function</span>(){
                server.removeListener( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">request</span><span style="color:#710">&quot;</span></span>, next );
                server.removeListener( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">close</span><span style="color:#710">&quot;</span></span>, request.stop );
        } );
});

<span style="color:#777">// respond to requests</span>
request
.seq( pullFromDatabase )
.val( <span style="color:#080;font-weight:bold">function</span>(data,res){
        res.end( data );
} );

<span style="color:#777">// node teardown</span>
process.on( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">SIGINT</span><span style="color:#710">&quot;</span></span>, request.stop );
</pre></div>
</div>
</div>

<p>The <code>next(..)</code> trigger can also adapt to node streams easily, using <code>onStream(..)</code> and <code>unStream(..)</code>:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>ASQ.react( <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">setup</span>(next){
        <span style="color:#080;font-weight:bold">var</span> fstream = fs.createReadStream( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">/some/file</span><span style="color:#710">&quot;</span></span> );

        <span style="color:#777">// pipe the stream's &quot;data&quot; event to `next(..)`</span>
        next.onStream( fstream );

        <span style="color:#777">// listen for the end of the stream</span>
        fstream.on( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">end</span><span style="color:#710">&quot;</span></span>, <span style="color:#080;font-weight:bold">function</span>(){
                next.unStream( fstream );
        } );
} )
.seq( .. )
.then( .. )
.val( .. );
</pre></div>
</div>
</div>

<p>You can also use sequence combinations to compose multiple reactive sequence streams:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> sq1 = ASQ.react( .. ).seq( .. ).then( .. );
<span style="color:#080;font-weight:bold">var</span> sq2 = ASQ.react( .. ).seq( .. ).then( .. );

<span style="color:#080;font-weight:bold">var</span> sq3 = ASQ.react(..)
.gate(
        sq1,
        sq2
)
.then( .. );
</pre></div>
</div>
</div>

<p>The main takeaway is that <code>ASQ.react(..)</code> is a lightweight adaptation of F/RP concepts, enabling the wiring of an event stream to a sequence, hence the term “reactive sequence.” Reactive sequences are generally capable enough for basic reactive uses.</p>

<p><strong>Note:</strong> Here’s an example of using <code>ASQ.react(..)</code> in managing UI state (http://jsbin.com/rozipaki/6/edit?js,output), and another example of handling HTTP request/response streams with <code>ASQ.react(..)</code> (https://gist.github.com/getify/bba5ec0de9d6047b720e).</p>

<h2 id="generator-coroutine">Generator Coroutine</h2>

<p>Hopefully Chapter 4 helped you get pretty familiar with ES6 generators. In particular, we want to revisit the “Generator Concurrency” discussion, and push it even further.</p>

<p>We imagined a <code>runAll(..)</code> utility that could take two or more generators and run them concurrently, letting them cooperatively <code>yield</code> control from one to the next, with optional message passing.</p>

<p>In addition to being able to run a single generator to completion, the <code>ASQ#runner(..)</code> we discussed in Appendix A is a similar implementation of the concepts of <code>runAll(..)</code>, which can run multiple generators concurrently to completion.</p>

<p>So let’s see how we can implement the concurrent Ajax scenario from Chapter 4:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>ASQ(
        <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">http://some.url.2</span><span style="color:#710">&quot;</span></span>
)
.runner(
        <span style="color:#080;font-weight:bold">function</span>*(token){
                <span style="color:#777">// transfer control</span>
                yield token;

                <span style="color:#080;font-weight:bold">var</span> url1 = token.messages[<span style="color:#00D">0</span>]; <span style="color:#777">// &quot;http://some.url.1&quot;</span>

                <span style="color:#777">// clear out messages to start fresh</span>
                token.messages = [];

                <span style="color:#080;font-weight:bold">var</span> p1 = request( url1 );

                <span style="color:#777">// transfer control</span>
                yield token;

                token.messages.push( yield p1 );
        },
        <span style="color:#080;font-weight:bold">function</span>*(token){
                <span style="color:#080;font-weight:bold">var</span> url2 = token.messages[<span style="color:#00D">0</span>]; <span style="color:#777">// &quot;http://some.url.2&quot;</span>

                <span style="color:#777">// message pass and transfer control</span>
                token.messages[<span style="color:#00D">0</span>] = <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">http://some.url.1</span><span style="color:#710">&quot;</span></span>;
                yield token;

                <span style="color:#080;font-weight:bold">var</span> p2 = request( url2 );

                <span style="color:#777">// transfer control</span>
                yield token;

                token.messages.push( yield p2 );

                <span style="color:#777">// pass along results to next sequence step</span>
                <span style="color:#080;font-weight:bold">return</span> token.messages;
        }
)
.val( <span style="color:#080;font-weight:bold">function</span>(res){
        <span style="color:#777">// `res[0]` comes from &quot;http://some.url.1&quot;</span>
        <span style="color:#777">// `res[1]` comes from &quot;http://some.url.2&quot;</span>
} );
</pre></div>
</div>
</div>

<p>The main differences between <code>ASQ#runner(..)</code> and <code>runAll(..)</code> are as follows:</p>

<ul>
  <li>Each generator (coroutine) is provided an argument we call <code>token</code>, which is the special value to <code>yield</code> when you want to explicitly transfer control to the next coroutine.</li>
  <li><code>token.messages</code> is an array that holds any messages passed in from the previous sequence step. It’s also a data structure that you can use to share messages between coroutines.</li>
  <li><code>yield</code>ing a Promise (or sequence) value does not transfer control, but instead pauses the coroutine processing until that value is ready.</li>
  <li>The last <code>return</code>ed or <code>yield</code>ed value from the coroutine processing run will be forward passed to the next step in the sequence.</li>
</ul>

<p>It’s also easy to layer helpers on top of the base <code>ASQ#runner(..)</code> functionality to suit different uses.</p>

<h3 id="state-machines">State Machines</h3>

<p>One example that may be familiar to many programmers is state machines. You can, with the help of a simple cosmetic utility, create an easy-to-express state machine processor.</p>

<p>Let’s imagine such a utility. We’ll call it <code>state(..)</code>, and will pass it two arguments: a state value and a generator that handles that state. <code>state(..)</code> will do the dirty work of creating and returning an adapter generator to pass to <code>ASQ#runner(..)</code>.</p>

<p>Consider:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">state</span>(val,handler) {
        <span style="color:#777">// make a coroutine handler for this state</span>
        <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">function</span>*(token) {
                <span style="color:#777">// state transition handler</span>
                <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">transition</span>(to) {
                        token.messages[<span style="color:#00D">0</span>] = to;
                }

                <span style="color:#777">// set initial state (if none set yet)</span>
                <span style="color:#080;font-weight:bold">if</span> (token.messages.length &lt; <span style="color:#00D">1</span>) {
                        token.messages[<span style="color:#00D">0</span>] = val;
                }

                <span style="color:#777">// keep going until final state (false) is reached</span>
                <span style="color:#080;font-weight:bold">while</span> (token.messages[<span style="color:#00D">0</span>] !== <span style="color:#069">false</span>) {
                        <span style="color:#777">// current state matches this handler?</span>
                        <span style="color:#080;font-weight:bold">if</span> (token.messages[<span style="color:#00D">0</span>] === val) {
                                <span style="color:#777">// delegate to state handler</span>
                                yield *handler( transition );
                        }

                        <span style="color:#777">// transfer control to another state handler?</span>
                        <span style="color:#080;font-weight:bold">if</span> (token.messages[<span style="color:#00D">0</span>] !== <span style="color:#069">false</span>) {
                                yield token;
                        }
                }
        };
}
</pre></div>
</div>
</div>

<p>If you look closely, you’ll see that <code>state(..)</code> returns back a generator that accepts a <code>token</code>, and then it sets up a <code>while</code> loop that will run until the state machine reaches its final state (which we arbitrarily pick as the <code>false</code> value); that’s exactly the kind of generator we want to pass to <code>ASQ#runner(..)</code>!</p>

<p>We also arbitrarily reserve the <code>token.messages[0]</code> slot as the place where the current state of our state machine will be tracked, which means we can even seed the initial state as the value passed in from the previous step in the sequence.</p>

<p>How do we use the <code>state(..)</code> helper along with <code>ASQ#runner(..)</code>?</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> prevState;

ASQ(
        <span style="color:#777">/* optional: initial state value */</span>
        <span style="color:#00D">2</span>
)
<span style="color:#777">// run our state machine</span>
<span style="color:#777">// transitions: 2 -&gt; 3 -&gt; 1 -&gt; 3 -&gt; false</span>
.runner(
        <span style="color:#777">// state `1` handler</span>
        state( <span style="color:#00D">1</span>, <span style="color:#080;font-weight:bold">function</span> *stateOne(transition){
                console.log( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">in state 1</span><span style="color:#710">&quot;</span></span> );

                prevState = <span style="color:#00D">1</span>;
                yield transition( <span style="color:#00D">3</span> );        <span style="color:#777">// goto state `3`</span>
        } ),

        <span style="color:#777">// state `2` handler</span>
        state( <span style="color:#00D">2</span>, <span style="color:#080;font-weight:bold">function</span> *stateTwo(transition){
                console.log( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">in state 2</span><span style="color:#710">&quot;</span></span> );

                prevState = <span style="color:#00D">2</span>;
                yield transition( <span style="color:#00D">3</span> );        <span style="color:#777">// goto state `3`</span>
        } ),

        <span style="color:#777">// state `3` handler</span>
        state( <span style="color:#00D">3</span>, <span style="color:#080;font-weight:bold">function</span> *stateThree(transition){
                console.log( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">in state 3</span><span style="color:#710">&quot;</span></span> );

                <span style="color:#080;font-weight:bold">if</span> (prevState === <span style="color:#00D">2</span>) {
                        prevState = <span style="color:#00D">3</span>;
                        yield transition( <span style="color:#00D">1</span> ); <span style="color:#777">// goto state `1`</span>
                }
                <span style="color:#777">// all done!</span>
                <span style="color:#080;font-weight:bold">else</span> {
                        yield <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">That's all folks!</span><span style="color:#710">&quot;</span></span>;

                        prevState = <span style="color:#00D">3</span>;
                        yield transition( <span style="color:#069">false</span> ); <span style="color:#777">// terminal state</span>
                }
        } )
)
<span style="color:#777">// state machine complete, so move on</span>
.val( <span style="color:#080;font-weight:bold">function</span>(msg){
        console.log( msg );        <span style="color:#777">// That's all folks!</span>
} );
</pre></div>
</div>
</div>

<p>It’s important to note that the <code>*stateOne(..)</code>, <code>*stateTwo(..)</code>, and <code>*stateThree(..)</code> generators themselves are reinvoked each time that state is entered, and they finish when you <code>transition(..)</code> to another value. While not shown here, of course these state generator handlers can be asynchronously paused by <code>yield</code>ing Promises/sequences/thunks.</p>

<p>The underneath hidden generators produced by the <code>state(..)</code> helper and actually passed to <code>ASQ#runner(..)</code> are the ones that continue to run concurrently for the length of the state machine, and each of them handles cooperatively <code>yield</code>ing control to the next, and so on.</p>

<p><strong>Note:</strong> See this “ping pong” example (http://jsbin.com/qutabu/1/edit?js,output) for more illustration of using cooperative concurrency with generators driven by <code>ASQ#runner(..)</code>.</p>

<h2 id="communicating-sequential-processes-csp">Communicating Sequential Processes (CSP)</h2>

<p>“Communicating Sequential Processes” (CSP) was first described by C. A. R. Hoare in a 1978 academic paper (http://dl.acm.org/citation.cfm?doid=359576.359585), and later in a 1985 book (http://www.usingcsp.com/) of the same name. CSP describes a formal method for concurrent “processes” to interact (aka “communicate”) during processing.</p>

<p>You may recall that we examined concurrent “processes” back in Chapter 1, so our exploration of CSP here will build upon that understanding.</p>

<p>Like most great concepts in computer science, CSP is heavily steeped in academic formalism, expressed as a process algebra. However, I suspect symbolic algebra theorems won’t make much practical difference to the reader, so we will want to find some other way of wrapping our brains around CSP.</p>

<p>I will leave much of the formal description and proof of CSP to Hoare’s writing, and to many other fantastic writings since. Instead, we will try to just briefly explain the idea of CSP in as un-academic and hopefully intuitively understandable a way as possible.</p>

<h3 id="message-passing">Message Passing</h3>

<p>The core principle in CSP is that all communication/interaction between otherwise independent processes must be through formal message passing. Perhaps counter to your expectations, CSP message passing is described as a synchronous action, where the sender process and the receiver process have to mutually be ready for the message to be passed.</p>

<p>How could such synchronous messaging possibly be related to asynchronous programming in JavaScript?</p>

<p>The concreteness of relationship comes from the nature of how ES6 generators are used to produce synchronous-looking actions that under the covers can indeed either be synchronous or (more likely) asynchronous.</p>

<p>In other words, two or more concurrently running generators can appear to synchronously message each other while preserving the fundamental asynchrony of the system because each generator’s code is paused (aka “blocked”) waiting on resumption of an asynchronous action.</p>

<p>How does this work?</p>

<p>Imagine a generator (aka “process”) called “A” that wants to send a message to generator “B.” First, “A” <code>yield</code>s the message (thus pausing “A”) to be sent to “B.” When “B” is ready and takes the message, “A” is then resumed (unblocked).</p>

<p>Symmetrically, imagine a generator “A” that wants a message <strong>from</strong> “B.” “A” <code>yield</code>s its request (thus pausing “A”) for the message from “B,” and once “B” sends a message, “A” takes the message and is resumed.</p>

<p>One of the more popular expressions of this CSP message passing theory comes from ClojureScript’s core.async library, and also from the <em>go</em> language. These takes on CSP embody the described communication semantics in a conduit that is opened between processes called a “channel.”</p>

<p><strong>Note:</strong> The term <em>channel</em> is used in part because there are modes in which more than one value can be sent at once into the “buffer” of the channel; this is similar to what you may think of as a stream. We won’t go into depth about it here, but it can be a very powerful technique for managing streams of data.</p>

<p>In the simplest notion of CSP, a channel that we create between “A” and “B” would have a method called <code>take(..)</code> for blocking to receive a value, and a method called <code>put(..)</code> for blocking to send a value.</p>

<p>This might look like:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> ch = channel();

<span style="color:#080;font-weight:bold">function</span> *foo() {
        <span style="color:#080;font-weight:bold">var</span> msg = yield take( ch );

        console.log( msg );
}

<span style="color:#080;font-weight:bold">function</span> *bar() {
        yield put( ch, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Hello World</span><span style="color:#710">&quot;</span></span> );

        console.log( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">message sent</span><span style="color:#710">&quot;</span></span> );
}

run( foo );
run( bar );
<span style="color:#777">// Hello World</span>
<span style="color:#777">// &quot;message sent&quot;</span>
</pre></div>
</div>
</div>

<p>Compare this structured, synchronous(-looking) message passing interaction to the informal and unstructured message sharing that <code>ASQ#runner(..)</code> provides through the <code>token.messages</code> array and cooperative <code>yield</code>ing. In essence, <code>yield put(..)</code> is a single operation that both sends the value and pauses execution to transfer control, whereas in earlier examples we did those as separate steps.</p>

<p>Moreover, CSP stresses that you don’t really explicitly “transfer control,” but rather you design your concurrent routines to block expecting either a value received from the channel, or to block expecting to try to send a message on the channel. The blocking around receiving or sending messages is how you coordinate sequencing of behavior between the coroutines.</p>

<p><strong>Note:</strong> Fair warning: this pattern is very powerful but it’s also a little mind twisting to get used to at first. You will want to practice this a bit to get used to this new way of thinking about coordinating your concurrency.</p>

<p>There are several great libraries that have implemented this flavor of CSP in JavaScript, most notably “js-csp” (https://github.com/ubolonton/js-csp), which James Long (http://twitter.com/jlongster) forked (https://github.com/jlongster/js-csp) and has written extensively about (http://jlongster.com/Taming-the-Asynchronous-Beast-with-CSP-in-JavaScript). Also, it cannot be stressed enough how amazing the many writings of David Nolen (http://twitter.com/swannodette) are on the topic of adapting ClojureScript’s go-style core.async CSP into JS generators (http://swannodette.github.io/2013/08/24/es6-generators-and-csp/).</p>

<h3 id="asynquence-csp-emulation">asynquence CSP emulation</h3>

<p>Because we’ve been discussing async patterns here in the context of my <em>asynquence</em> library, you might be interested to see that we can fairly easily add an emulation layer on top of <code>ASQ#runner(..)</code> generator handling as a nearly perfect porting of the CSP API and behavior. This emulation layer ships as an optional part of the “asynquence-contrib” package alongside <em>asynquence</em>.</p>

<p>Very similar to the <code>state(..)</code> helper from earlier, <code>ASQ.csp.go(..)</code> takes a generator – in go/core.async terms, it’s known as a goroutine – and adapts it to use with <code>ASQ#runner(..)</code> by returning a new generator.</p>

<p>Instead of being passed a <code>token</code>, your goroutine receives an initially created channel (<code>ch</code> below) that all goroutines in this run will share. You can create more channels (which is often quite helpful!) with <code>ASQ.csp.chan(..)</code>.</p>

<p>In CSP, we model all asynchrony in terms of blocking on channel messages, rather than blocking waiting for a Promise/sequence/thunk to complete.</p>

<p>So, instead of <code>yield</code>ing the Promise returned from <code>request(..)</code>, <code>request(..)</code> should return a channel that you <code>take(..)</code> a value from. In other words, a single-value channel is roughly equivalent in this context/usage to a Promise/sequence.</p>

<p>Let’s first make a channel-aware version of <code>request(..)</code>:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">request</span>(url) {
        <span style="color:#080;font-weight:bold">var</span> ch = ASQ.csp.channel();
        ajax( url ).then( <span style="color:#080;font-weight:bold">function</span>(content){
                <span style="color:#777">// `putAsync(..)` is a version of `put(..)` that</span>
                <span style="color:#777">// can be used outside of a generator. It returns</span>
                <span style="color:#777">// a promise for the operation's completion. We</span>
                <span style="color:#777">// don't use that promise here, but we could if</span>
                <span style="color:#777">// we needed to be notified when the value had</span>
                <span style="color:#777">// been `take(..)`n.</span>
                ASQ.csp.putAsync( ch, content );
        } );
        <span style="color:#080;font-weight:bold">return</span> ch;
}
</pre></div>
</div>
</div>

<p>From Chapter 3, “promisory” is a Promise-producing utility, “thunkory” from Chapter 4 is a thunk-producing utility, and finally, in Appendix A we invented “sequory” for a sequence-producing utility.</p>

<p>Naturally, we need to coin a symmetric term here for a channel-producing utility. So let’s unsurprisingly call it a “chanory” (“channel” + “factory”). As an exercise for the reader, try your hand at defining a <code>channelify(..)</code> utility similar to <code>Promise.wrap(..)</code>/<code>promisify(..)</code> (Chapter 3), <code>thunkify(..)</code> (Chapter 4), and <code>ASQ.wrap(..)</code> (Appendix A).</p>

<p>Now consider the concurrent Ajax example using <em>asyquence</em>-flavored CSP:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>ASQ()
.runner(
        ASQ.csp.go( <span style="color:#080;font-weight:bold">function</span>*(ch){
                yield ASQ.csp.put( ch, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">http://some.url.2</span><span style="color:#710">&quot;</span></span> );

                <span style="color:#080;font-weight:bold">var</span> url1 = yield ASQ.csp.take( ch );
                <span style="color:#777">// &quot;http://some.url.1&quot;</span>

                <span style="color:#080;font-weight:bold">var</span> res1 = yield ASQ.csp.take( request( url1 ) );

                yield ASQ.csp.put( ch, res1 );
        } ),
        ASQ.csp.go( <span style="color:#080;font-weight:bold">function</span>*(ch){
                <span style="color:#080;font-weight:bold">var</span> url2 = yield ASQ.csp.take( ch );
                <span style="color:#777">// &quot;http://some.url.2&quot;</span>

                yield ASQ.csp.put( ch, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">http://some.url.1</span><span style="color:#710">&quot;</span></span> );

                <span style="color:#080;font-weight:bold">var</span> res2 = yield ASQ.csp.take( request( url2 ) );
                <span style="color:#080;font-weight:bold">var</span> res1 = yield ASQ.csp.take( ch );

                <span style="color:#777">// pass along results to next sequence step</span>
                ch.buffer_size = <span style="color:#00D">2</span>;
                ASQ.csp.put( ch, res1 );
                ASQ.csp.put( ch, res2 );
        } )
)
.val( <span style="color:#080;font-weight:bold">function</span>(res1,res2){
        <span style="color:#777">// `res1` comes from &quot;http://some.url.1&quot;</span>
        <span style="color:#777">// `res2` comes from &quot;http://some.url.2&quot;</span>
} );
</pre></div>
</div>
</div>

<p>The message passing that trades the URL strings between the two goroutines is pretty straightforward. The first goroutine makes an Ajax request to the first URL, and that response is put onto the <code>ch</code> channel. The second goroutine makes an Ajax request to the second URL, then gets the first response <code>res1</code> off the <code>ch</code> channel. At that point, both responses <code>res1</code> and <code>res2</code> are completed and ready.</p>

<p>If there are any remaining values in the <code>ch</code> channel at the end of the goroutine run, they will be passed along to the next step in the sequence. So, to pass out message(s) from the final goroutine, <code>put(..)</code> them into <code>ch</code>. As shown, to avoid the blocking of those final <code>put(..)</code>s, we switch <code>ch</code> into buffering mode by setting its <code>buffer_size</code> to <code>2</code> (default: <code>0</code>).</p>

<p><strong>Note:</strong> See many more examples of using <em>asynquence</em>-flavored CSP here (https://gist.github.com/getify/e0d04f1f5aa24b1947ae).</p>

<h2 id="review">Review</h2>

<p>Promises and generators provide the foundational building blocks upon which we can build much more sophisticated and capable asynchrony.</p>

<p><em>asynquence</em> has utilities for implementing <em>iterable sequences</em>, <em>reactive sequences</em> (aka “Observables”), <em>concurrent coroutines</em>, and even <em>CSP goroutines</em>.</p>

<p>Those patterns, combined with the continuation-callback and Promise capabilities, gives <em>asynquence</em> a powerful mix of different asynchronous functionalities, all integrated in one clean async flow control abstraction: the sequence.</p>

    </div>
  </body>
</html>

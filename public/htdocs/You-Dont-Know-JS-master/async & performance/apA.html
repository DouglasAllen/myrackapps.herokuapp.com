<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/>
      <!--<link rel="stylesheet" type="text/css" href="stylesheets/default.css">-->
      <!--<!--<link href="stylesheets/d.css" rel="stylesheet" type="text/css" />-->
      <!--<link href="stylesheets/fixes.css" rel="stylesheet" type="text/css" />-->
      <!--<link href="stylesheets/main.css" rel="stylesheet" type="text/css" />-->
      <!--<link href="stylesheets/reset.css" rel="stylesheet" type="text/css" />-->
      <!--<link href="stylesheets/print.css" rel="stylesheet" type="text/css" />-->
      <!--<link href="stylesheets/styles.css" rel="stylesheet" type="text/css" />-->
      <!--<link href="stylesheets/style.css" rel="stylesheet" type="text/css" />-->

     <style>
/* Site */
body {
      font-family: Verdana, Lucida Grande, Arial, Helvetica, sans-serif;
      font-size: 16px;
      line-height: 18px;
      padding-top: 10px;
      padding-bottom: 10px;
      background-color: white;
      padding: 30px;
      color: #333;
      border: 1px solid #aaa;
      max-width: 900px;
      margin: 20px auto;	
      background: #fff url(/images/topbluefade.gif) repeat-x center top;	
}

    body > *:first-child {
      margin-top: 0 !important;
    }

    body > *:last-child {
      margin-bottom: 0 !important;
    }

    a {
      color: #4183C4;
      text-decoration: none;
    }

    a.absent {
      color: #cc0000;
    }

    a.anchor {
      display: block;
      padding-left: 30px;
      margin-left: -30px;
      cursor: pointer;
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
    }

    h1, h2, h3, h4, h5, h6 {
      margin: 20px 0 10px;
      padding: 0;
      font-weight: bold;
      -webkit-font-smoothing: antialiased;
      cursor: text;
      position: relative;
    }

    h2:first-child, h1:first-child, h1:first-child + h2, h3:first-child, h4:first-child, h5:first-child, h6:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
      text-decoration: none;
    }

    h1 tt, h1 code {
      font-size: inherit;
    }

    h2 tt, h2 code {
      font-size: inherit;
    }

    h3 tt, h3 code {
      font-size: inherit;
    }

    h4 tt, h4 code {
      font-size: inherit;
    }

    h5 tt, h5 code {
      font-size: inherit;
    }

    h6 tt, h6 code {
      font-size: inherit;
    }

    h1 {
      font-size: 28px;
      color: black;
    }

    h2 {
      font-size: 24px;
      border-bottom: 1px solid #cccccc;
      color: black;
    }

    h3 {
      font-size: 18px;
    }

    h4 {
      font-size: 16px;
    }

    h5 {
      font-size: 14px;
    }

    h6 {
      color: #777777;
      font-size: 14px;
    }

    p, blockquote, ul, ol, dl, li, table, pre {
      margin: 3px 0;
    }

    hr {
      background: transparent url("http://tinyurl.com/bq5kskr") repeat-x 0 0;
      border: 0 none;
      color: #cccccc;
      height: 4px;
      padding: 0;
    }

    body > h2:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    body > h1:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    body > h1:first-child + h2 {
      margin-top: 0;
      padding-top: 0;
    }

    body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
      margin-top: 0;
      padding-top: 0;
    }

    a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
      margin-top: 0;
      padding-top: 0;
    }

    h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
      margin-top: 0;
    }

    li p.first {
      display: inline-block;
    }

    ul, ol {
      padding-left: 30px;
    }

    ul :first-child, ol :first-child {
      margin-top: 0;
    }

    ul :last-child, ol :last-child {
      margin-bottom: 0;
    }

    dl {
      padding: 0;
    }

    dl dt {
      font-size: 14px;
      font-weight: bold;
      font-style: italic;
      padding: 0;
      margin: 15px 0 5px;
    }

    dl dt:first-child {
      padding: 0;
    }

    dl dt > :first-child {
      margin-top: 0;
    }

    dl dt > :last-child {
      margin-bottom: 0;
    }

    dl dd {
      margin: 0 0 15px;
      padding: 0 15px;
    }

    dl dd > :first-child {
      margin-top: 0;
    }

    dl dd > :last-child {
      margin-bottom: 0;
    }

    blockquote {
      border-left: 4px solid #dddddd;
      padding: 0 15px;
      color: #777777;
    }

    blockquote > :first-child {
      margin-top: 0;
    }

    blockquote > :last-child {
      margin-bottom: 0;
    }

    table {
      padding: 0;
    }
    table tr {
      border-top: 1px solid #cccccc;
      background-color: white;
      margin: 0;
      padding: 0;
    }

    table tr:nth-child(2n) {
      background-color: #f8f8f8;
    }

    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      text-align: left;
      margin: 0;
      padding: 6px 13px;
    }

    table tr td {
      border: 1px solid #cccccc;
      text-align: left;
      margin: 0;
      padding: 6px 13px;
    }

    table tr th :first-child, table tr td :first-child {
      margin-top: 0;
    }

    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0;
    }

    img {
      max-width: 100%;
    }

    span.frame {
      display: block;
      overflow: hidden;
    }

    span.frame > span {
      border: 1px solid #dddddd;
      display: block;
      float: left;
      overflow: hidden;
      margin: 13px 0 0;
      padding: 7px;
      width: auto;
    }

    span.frame span img {
      display: block;
      float: left;
    }

    span.frame span span {
      clear: both;
      color: #333333;
      display: block;
      padding: 5px 0 0;
    }

    span.align-center {
      display: block;
      overflow: hidden;
      clear: both;
    }

    span.align-center > span {
      display: block;
      overflow: hidden;
      margin: 13px auto 0;
      text-align: center;
    }

    span.align-center span img {
      margin: 0 auto;
      text-align: center;
    }

    span.align-right {
      display: block;
      overflow: hidden;
      clear: both;
    }

    span.align-right > span {
      display: block;
      overflow: hidden;
      margin: 13px 0 0;
      text-align: right;
    }

    span.align-right span img {
      margin: 0;
      text-align: right;
    }

    span.float-left {
      display: block;
      margin-right: 13px;
      overflow: hidden;
      float: left;
    }

    span.float-left span {
      margin: 13px 0 0;
    }

    span.float-right {
      display: block;
      margin-left: 13px;
      overflow: hidden;
      float: right;
    }

    span.float-right > span {
      display: block;
      overflow: hidden;
      margin: 13px auto 0;
      text-align: right;
    }

    code, tt {
      font-family: "Lucida Console", "Courier New", courier;
      font-size: 12px;
      margin: 0 2px;
      padding: 3px 5px;
      white-space: nowrap;
      border: 1px solid #eaeaea;
      background-color: #f8f8f8;
      border-radius: 3px;
    }

    pre code {
      margin: 0;
      padding: 0;
      white-space: pre;
      border: none;
      background: transparent;
    }

    .highlight pre {
      background-color: #f8f8f8;
      border: 1px solid #cccccc;
      font-size: 13px;
      line-height: 19px;
      overflow: auto;
      padding: 6px 10px;
      border-radius: 3px;
    }

    pre {
      background-color: #f8f8f8;
      border: 1px solid #cccccc;
      font-size: 13px;
      line-height: 19px;
      overflow: auto;
      padding: 6px 10px;
      border-radius: 3px;
    }

    pre code, pre tt {
      background-color: transparent;
      border: none;
    }

    span.line-numbers {
      margin-right: 10px;
    }

    img.logo {
      display: block;
      margin: 10px auto;
    }

    h1.logo {
      text-align: center;
      font-size: 40px;
    }
a img {
	border: none;
}
a.nohover {
	background-color: transparent !important;
}
a.align-right {
	float: right;
	margin: 0px 0px 0px 10px;
}
a.align-right img {
	display: block;
}
a.align-center {
	display: inline-block;
	margin: 0px 5px;
}
a.align-center img {
	display: block;
}
img.bordered {
	background-color: #fff;
	border: 1px solid #CCC;
	padding: 1px;
}
img.align-right {
	float: right;
	margin: 0px 0px 0px 10px;
}
span.highlight {
	background-color: #ffc;
}
div.section {
	margin: 0px auto;
	overflow: hidden;
	width: 700px;
}
div.section h2 {
	color: #000;
	float: left;
	font-family: Georgia;
	font-size: 28px;
	font-weight: normal;
	line-height: 120%;
	margin: 0px 0px 20px 0px;
	text-align: right;
	width: 200px;
}
div.section h3 {
	color: #900;
	font-family: Georgia;
	font-size: 18px;
	margin: 0px 0px 0px 250px;
	line-height: 140%;
}
div.section h3.pull-left {
	font-size: 20px;
	font-weight: normal;
	line-height: 120%;
	color: #900;
	float: left;
	margin: 0px 0px 10px 0px;
	width: 200px;
	text-align: right;
}
div.section p {
	font-family: Georgia;
	font-size: 18px;
	line-height: 140%;
	margin: 0px 0px 25px 250px;
	width: 450px;
}
div.section h2.small {
	font-size: 20px;
}
div.section p.small {
	font-size: 14px;
}
div.section blockquote {
	margin: 0px 0px 25px 250px;
	width: 450px;
}
div.section blockquote p {
	font-family: Courier New, Courier, mono;
	font-size: 16px;
	font-weight: bold;
	line-height: 140%;
	margin: 0px 25px;
	width: auto;
}
div.section p.more {
	font-size: 12px;
	text-align: center;
}
div.section p.centered {
	text-align: center;
}
div.section p.download,
div.section p.credit {
	font-size: 14px;
}
div.section p.footnote,
div.section p.sponsorship {
	font-size: 12px;
}
div.section img.biopic {
	background-color: #fff;
	border: 2px solid #ccc;
	padding: 2px;
	float: left;
	margin: 0px 0px 10px 40px;
}
div.section a.screencast {
	background-color: transparent !important;
	float: left;
	clear: left;
	margin: 0px 0px 25px 25px;
}
div.section a.screencast img {
	display: block;
	background-color: #fff;
	border: 2px solid #ccc;
	padding: 2px;
}
div.section ul.grid {
	list-style: none;
	margin: 0px 0px 15px 280px;
	padding: 0px;
	overflow: hidden;
	width: 420px;
}
div.section ul.grid li {
	float: left;
	margin: 0px 0px 0px 0px;
	height: 160px;
	width: 200px;
}
div.section ul.grid li a {
	background-color: transparent !important;
	display: block;
	margin: 0px 0px 5px 0px;
}
div.section ul.grid li img {
	display: block;
	border: 1px solid #ccc;
	padding: 1px;
}
div.section ul.grid li p {
	font-size: 10px;
	font-family: inherit;
	margin: 0px;
	width: auto;
}
div.section ul.grid li p a {
	display: inline;
}
div.section ul.grid li p a:hover {
	background-color: #f4dda6 !important;
}
div.section div.video {
	margin: 0px 0px 25px 250px;
	width: 450px;
}
div.section ul.links {
	list-style: none;
	float: left;
	clear: left;
	text-align: right;
	width: 200px;
	padding: 0px;
	margin: 0px 0px 20px 0px;
	font-family: Georgia;
	font-size: 14px;
	line-height: 140%;
	overflow: hidden;
}
div.section ul.links li {
	float: right;
	clear: right;
}
div.section ul.links li.rss {
	background: url(/images/rss.png) no-repeat 0px 1px;
	padding: 0px 0px 0px 22px;
}
div.section code {
	font-family: Courier New, Courier, mono;
	font-size: 16px;
	font-weight: bold;
}
#navigation {
	width: 726px;
	margin: 15px auto 10px;
	font-size: 10px;
	line-height: 12px;
	text-align: center;
}
#navigation a {
	color: #000;
	font-weight: bold;
	font-size: 11px;
	text-decoration: underline;
}
#navigation a:hover {
	background-color: #000;
	color: #fff;
	text-decoration: none;
}
#article {
	padding: 0px 0px 20px 0px;
}
#article header {
	background: url(/images/rails.png) no-repeat left top;
	margin: 50px auto 32px;
	width: 606px;
	padding-left: 100px;
	text-align: center;
}
#article header h1 {
	margin: 0 auto 12px;
  font-family: "expressway",sans-serif;
  font-style: normal;
  font-weight: 700;
	font-size: 38px;
  line-height: 30px;
  color: #000000;
}
#article header h2 {
	margin: 0 auto;
  font-family: "expressway",sans-serif;
  font-style: normal;
  font-weight: 400;
	font-size: 21px;
	line-height: 24px;
	color: #999999;
}
#article p a,
#article ol a,
#article ul a {
	color: #369;
}
#article p a:hover,
#article ol a:hover,
#article ul a:hover {
	background-color: #f4dda6;
	text-decoration: none;
}
#article hr.rule {
	border: 0px;
	color: #bbb;
	background-color: #bbb;
	height: 1px;
	width: 670px;
	margin: 0px auto 25px;
}
#article p.missing {
	color: #000;
	font-family: Georgia;
	font-size: 28px;
	font-weight: normal;
	line-height: 120%;
	margin: 0px auto;
	text-align: center;
	width: 700px;
}
#footer {
	color: #666;
	font-size: 11px;
	margin: 0px auto;
	padding: 0px 0px 44px 0px;
	text-align: center;
	width: 726px;
}
#footer p {
	margin: 12px 0px;
}
#footer p a {
	color: #000;
}
#footer p a:hover {
	background-color: #333;
	color: #fff;
	text-decoration: none;
}
#sponsored_by {
	margin: 17px 0px !important;
}
#sponsored_by a:hover {
	background-color: transparent !important;
}
#sponsored_by a img {
	vertical-align: -7px;
}

/* Overview */
#announce {
	background-color: #981a21;
	color: #fff;
	font-size: 11px;
	line-height: 13px;
	margin: 0px;
	padding: 5px 0px;
	text-align: center;
}
#announce a {
	color: #fff !important;
	text-decoration: underline;
}
#announce a:hover {
	background-color: #000 !important;
	text-decoration: none;
}
#slivers {
	background: url(/images/herobackground.gif) repeat-x left top;
	border-top: 2px solid #F6E69F;
	border-bottom: 2px solid #F6E69F;
	padding: 10px;
}
#slivers ul {
	list-style: none;
	margin: 0px auto;
	padding: 0px;
	overflow: hidden;
	width: 792px;
}
#slivers ul li {
	float: left;
	margin: 0px 24px;
	width: 150px;
}
#slivers ul li h2 {
	color: #0e3062;
	font-family: Georgia;
	font-size: 22px;
	line-height: 24px;
	font-weight: normal;
	margin: 0px 0px 10px 0px;
	text-align: center;
}
#slivers ul li img {
	display: block;
	margin: 0px auto 5px;
}
#slivers ul li p {
	margin: 0px;
	text-align: center;
}
#slivers ul li p a {
	color: #000;
	font-size: 10px;
}
#slivers ul li p a:hover {
	background-color: #000;
	color: #fff;
	text-decoration: none;
}

#slideshow {
	font-family: Georgia;
	font-size: 16px;
	height: 132px;
	line-height: 140%;
	margin: 0px auto 30px;
	text-align: center;
	width: 700px;
	padding: 30px 0px 0px 0px;
	position: relative;
}
#slideshow blockquote {
	margin: 0px;
	position: absolute;
	width: 700px;
}
#slideshow blockquote p {
	margin: 0px;
}
#slideshow blockquote p cite {
	font-size: 14px;
	color: #464242;
}
#slideshow p.more {
	font-size: 14px;
	font-style: italic;
	margin: 0px;
	position: absolute;
	bottom: 0px;
	width: 700px;
}
#slideshow p.more a {
	color: #464242;
}
#slideshow p.more a:hover {
	background-color: #000;
	text-decoration: none;
}
#used_by ul {
	list-style: none;
	margin: 0px 0px 0px 280px;
	padding: 0px;
	overflow: hidden;
}
#used_by ul li {
	float: left;
	margin: 0px 0px 20px 0px;
	width: 209px;
}
#used_by ul li img {
	display: block;
	margin: 0px 0px 5px 0px;
}
#used_by ul li p {
	font-size: 10px;
	font-family: inherit;
	margin: 0px;
	width: auto;
}
/* Applications */
#applications {
	list-style: none;
	margin: 0px auto;
	padding: 0px 0px 0px 110px;
	overflow: hidden;
	width: 700px;
}
#applications li {
	float: left;
	width: 200px;
	margin: 0px 0px 20px 0px;
}
#applications li a {
	display: block;
	margin: 0px 0px 5px 0px;
	background-color: transparent !important;
}
#applications li a img {
	background-color: #fff;
	border: 1px solid #CCC;
	padding: 1px;
	display: block;
}
#applications li p {
	font-size: 10px;
	margin: 0px;
}
#applications li p a {
	display: inline;
}
#applications li p a:hover {
	background-color: #f4dda6 !important;
}
/* Quotes */
#article.quotes blockquote {
	font-family: Georgia;
	font-size: 18px;
	line-height: 140%;
	margin: 0px auto 25px;
	text-align: center;
	width: 700px;
	padding: 0px;
	position: relative;
}
#article.quotes blockquote p {
	margin: 0px;
}
#article.quotes blockquote p cite {
	font-size: 14px;
	color: #a69e8a;
}
/* Security Policy */
#article.security {
	margin: 50px auto 30px;
	width: 700px;
}
#article.security h2 {
	font-weight: bold;
	text-transform: uppercase;
	font-size: 20px;
	font-family: Arial, Helvetica, sans-serif;
	text-align: center;
	margin: 40px 0px 15px 0px;
}
#article.security h3 {
	color: #900;
	font-family: Georgia;
	font-size: 18px;
	margin: 0;
	line-height: 140%;
}
#article.security p,
#article.security ol {
	font-family: Georgia;
	font-size: 18px;
	line-height: 140%;
	margin: 0px 0px 25px 0px;
}
#article.security ol li {
	margin: 0px 0px 10px 0px;
}

     </style>
  </head>
  <body>
    <div id="containter">          
      <h1 id="you-dont-know-js-async--performance">You Don’t Know JS: Async &amp; Performance</h1>
<p># Appendix A: <em>asynquence</em> Library</p>

<p>Chapters 1 and 2 went into quite a bit of detail about typical asynchronous programming patterns and how they’re commonly solved with callbacks. But we also saw why callbacks are fatally limited in capability, which led us to Chapters 3 and 4, with Promises and generators offering a much more solid, trustable, and reason-able base to build your asynchrony on.</p>

<p>I referenced my own asynchronous library <em>asynquence</em> (http://github.com/getify/asynquence) – “async” + “sequence” = “asynquence” – several times in this book, and I want to now briefly explain how it works and why its unique design is important and helpful.</p>

<p>In the next appendix, we’ll explore some advanced async patterns, but you’ll probably want a library to make those palatable enough to be useful. We’ll use <em>asynquence</em> to express those patterns, so you’ll want to spend a little time here getting to know the library first.</p>

<p><em>asynquence</em> is obviously not the only option for good async coding; certainly there are many great libraries in this space. But <em>asynquence</em> provides a unique perspective by combining the best of all these patterns into a single library, and moreover is built on a single basic abstraction: the (async) sequence.</p>

<p>My premise is that sophisticated JS programs often need bits and pieces of various different asynchronous patterns woven together, and this is usually left entirely up to each developer to figure out. Instead of having to bring in two or more different async libraries that focus on different aspects of asynchrony, <em>asynquence</em> unifies them into variated sequence steps, with just one core library to learn and deploy.</p>

<p>I believe the value is strong enough with <em>asynquence</em> to make async flow control programming with Promise-style semantics super easy to accomplish, so that’s why we’ll exclusively focus on that library here.</p>

<p>To begin, I’ll explain the design principles behind <em>asynquence</em>, and then we’ll illustrate how its API works with code examples.</p>

<h2 id="sequences-abstraction-design">Sequences, Abstraction Design</h2>

<p>Understanding <em>asynquence</em> begins with understanding a fundamental abstraction: any series of steps for a task, whether they separately are synchronous or asynchronous, can be collectively thought of as a “sequence”. In other words, a sequence is a container that represents a task, and is comprised of individual (potentially async) steps to complete that task.</p>

<p>Each step in the sequence is controlled under the covers by a Promise (see Chapter 3). That is, every step you add to a sequence implicitly creates a Promise that is wired to the previous end of the sequence. Because of the semantics of Promises, every single step advancement in a sequence is asynchronous, even if you synchronously complete the step.</p>

<p>Moreover, a sequence will always proceed linearly from step to step, meaning that step 2 always comes after step 1 finishes, and so on.</p>

<p>Of course, a new sequence can be forked off an existing sequence, meaning the fork only occurs once the main sequence reaches that point in the flow. Sequences can also be combined in various ways, including having one sequence subsumed by another sequence at a particular point in the flow.</p>

<p>A sequence is kind of like a Promise chain. However, with Promise chains, there is no “handle” to grab that references the entire chain. Whichever Promise you have a reference to only represents the current step in the chain plus any other steps hanging off it. Essentially, you cannot hold a reference to a Promise chain unless you hold a reference to the first Promise in the chain.</p>

<p>There are many cases where it turns out to be quite useful to have a handle that references the entire sequence collectively. The most important of those cases is with sequence abort/cancel. As we covered extensively in Chapter 3, Promises themselves should never be able to be canceled, as this violates a fundamental design imperative: external immutability.</p>

<p>But sequences have no such immutability design principle, mostly because sequences are not passed around as future-value containers that need immutable value semantics. So sequences are the proper level of abstraction to handle abort/cancel behavior. <em>asynquence</em> sequences can be <code>abort()</code>ed at any time, and the sequence will stop at that point and not go for any reason.</p>

<p>There’s plenty more reasons to prefer a sequence abstraction on top of Promise chains, for flow control purposes.</p>

<p>First, Promise chaining is a rather manual process – one that can get pretty tedious once you start creating and chaining Promises across a wide swath of your programs – and this tedium can act counterproductively to dissuade the developer from using Promises in places where they are quite appropriate.</p>

<p>Abstractions are meant to reduce boilerplate and tedium, so the sequence abstraction is a good solution to this problem. With Promises, your focus is on the individual step, and there’s little assumption that you will keep the chain going. With sequences, the opposite approach is taken, assuming the sequence will keep having more steps added indefinitely.</p>

<p>This abstraction complexity reduction is especially powerful when you start thinking about higher-order Promise patterns (beyond <code>race([..])</code> and <code>all([..])</code>.</p>

<p>For example, in the middle of a sequence, you may want to express a step that is conceptually like a <code>try..catch</code> in that the step will always result in success, either the intended main success resolution or a positive nonerror signal for the caught error. Or, you might want to express a step that is like a retry/until loop, where it keeps trying the same step over and over until success occurs.</p>

<p>These sorts of abstractions are quite nontrivial to express using only Promise primitives, and doing so in the middle of an existing Promise chain is not pretty. But if you abstract your thinking to a sequence, and consider a step as a wrapper around a Promise, that step wrapper can hide such details, freeing you to think about the flow control in the most sensible way without being bothered by the details.</p>

<p>Second, and perhaps more importantly, thinking of async flow control in terms of steps in a sequence allows you to abstract out the details of what types of asynchronicity are involved with each individual step. Under the covers, a Promise will always control the step, but above the covers, that step can look either like a continuation callback (the simple default), or like a real Promise, or as a run-to-completion generator, or … Hopefully, you get the picture.</p>

<p>Third, sequences can more easily be twisted to adapt to different modes of thinking, such as event-, stream-, or reactive-based coding. <em>asynquence</em> provides a pattern I call “reactive sequences” (which we’ll cover later) as a variation on the “reactive observable” ideas in RxJS (“Reactive Extensions”), that lets a repeatable event fire off a new sequence instance each time. Promises are one-shot-only, so it’s quite awkward to express repetitious asynchrony with Promises alone.</p>

<p>Another alternate mode of thinking inverts the resolution/control capability in a pattern I call “iterable sequences”. Instead of each individual step internally controlling its own completion (and thus advancement of the sequence), the sequence is inverted so the advancement control is through an external iterator, and each step in the <em>iterable sequence</em> just responds to the <code>next(..)</code> <em>iterator</em> control.</p>

<p>We’ll explore all of these different variations as we go throughout the rest of this appendix, so don’t worry if we ran over those bits far too quickly just now.</p>

<p>The takeaway is that sequences are a more powerful and sensible abstraction for complex asynchrony than just Promises (Promise chains) or just generators, and <em>asynquence</em> is designed to express that abstraction with just the right level of sugar to make async programming more understandable and more enjoyable.</p>

<h2 id="asynquence-api"><em>asynquence</em> API</h2>

<p>To start off, the way you create a sequence (an <em>asynquence</em> instance) is with the <code>ASQ(..)</code> function. An <code>ASQ()</code> call with no parameters creates an empty initial sequence, whereas passing one or more values or functions to <code>ASQ(..)</code> sets up the sequence with each argument representing the initial steps of the sequence.</p>

<p><strong>Note:</strong> For the purposes of all code examples here, I will use the <em>asynquence</em> top-level identifier in global browser usage: <code>ASQ</code>. If you include and use <em>asynquence</em> through a module system (browser or server), you of course can define whichever symbol you prefer, and <em>asynquence</em> won’t care!</p>

<p>Many of the API methods discussed here are built into the core of <em>asynquence</em>, but others are provided through including the optional “contrib” plug-ins package. See the documentation for <em>asynquence</em> for whether a method is built in or defined via plug-in: http://github.com/getify/asynquence</p>

<h3 id="steps">Steps</h3>

<p>If a function represents a normal step in the sequence, that function is invoked with the first parameter being the continuation callback, and any subsequent parameters being any messages passed on from the previous step. The step will not complete until the continuation callback is called. Once it’s called, any arguments you pass to it will be sent along as messages to the next step in the sequence.</p>

<p>To add an additional normal step to the sequence, call <code>then(..)</code> (which has essentially the exact same semantics as the <code>ASQ(..)</code> call):</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>ASQ(
        <span style="color:#777">// step 1</span>
        <span style="color:#080;font-weight:bold">function</span>(done){
                setTimeout( <span style="color:#080;font-weight:bold">function</span>(){
                        done( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Hello</span><span style="color:#710">&quot;</span></span> );
                }, <span style="color:#00D">100</span> );
        },
        <span style="color:#777">// step 2</span>
        <span style="color:#080;font-weight:bold">function</span>(done,greeting) {
                setTimeout( <span style="color:#080;font-weight:bold">function</span>(){
                        done( greeting + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20"> World</span><span style="color:#710">&quot;</span></span> );
                }, <span style="color:#00D">100</span> );
        }
)
<span style="color:#777">// step 3</span>
.then( <span style="color:#080;font-weight:bold">function</span>(done,msg){
        setTimeout( <span style="color:#080;font-weight:bold">function</span>(){
                done( msg.toUpperCase() );
        }, <span style="color:#00D">100</span> );
} )
<span style="color:#777">// step 4</span>
.then( <span style="color:#080;font-weight:bold">function</span>(done,msg){
        console.log( msg );                        <span style="color:#777">// HELLO WORLD</span>
} );
</pre></div>
</div>
</div>

<p><strong>Note:</strong> Though the name <code>then(..)</code> is identical to the native Promises API, this <code>then(..)</code> is different. You can pass as few or as many functions or values to <code>then(..)</code> as you’d like, and each is taken as a separate step. There’s no two-callback fulfilled/rejected semantics involved.</p>

<p>Unlike with Promises, where to chain one Promise to the next you have to create and <code>return</code> that Promise from a <code>then(..)</code> fulfillment handler, with <em>asynquence</em>, all you need to do is call the continuation callback – I always call it <code>done()</code> but you can name it whatever suits you – and optionally pass it completion messages as arguments.</p>

<p>Each step defined by <code>then(..)</code> is assumed to be asynchronous. If you have a step that’s synchronous, you can either just call <code>done(..)</code> right away, or you can use the simpler <code>val(..)</code> step helper:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#777">// step 1 (sync)</span>
ASQ( <span style="color:#080;font-weight:bold">function</span>(done){
        done( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Hello</span><span style="color:#710">&quot;</span></span> );        <span style="color:#777">// manually synchronous</span>
} )
<span style="color:#777">// step 2 (sync)</span>
.val( <span style="color:#080;font-weight:bold">function</span>(greeting){
        <span style="color:#080;font-weight:bold">return</span> greeting + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20"> World</span><span style="color:#710">&quot;</span></span>;
} )
<span style="color:#777">// step 3 (async)</span>
.then( <span style="color:#080;font-weight:bold">function</span>(done,msg){
        setTimeout( <span style="color:#080;font-weight:bold">function</span>(){
                done( msg.toUpperCase() );
        }, <span style="color:#00D">100</span> );
} )
<span style="color:#777">// step 4 (sync)</span>
.val( <span style="color:#080;font-weight:bold">function</span>(msg){
        console.log( msg );
} );
</pre></div>
</div>
</div>

<p>As you can see, <code>val(..)</code>-invoked steps don’t receive a continuation callback, as that part is assumed for you – and the parameter list is less cluttered as a result! To send a message along to the next step, you simply use <code>return</code>.</p>

<p>Think of <code>val(..)</code> as representing a synchronous “value-only” step, which is useful for synchronous value operations, logging, and the like.</p>

<h3 id="errors">Errors</h3>

<p>One important difference with <em>asynquence</em> compared to Promises is with error handling.</p>

<p>With Promises, each individual Promise (step) in a chain can have its own independent error, and each subsequent step has the ability to handle the error or not. The main reason for this semantic comes (again) from the focus on individual Promises rather than on the chain (sequence) as a whole.</p>

<p>I believe that most of the time, an error in one part of a sequence is generally not recoverable, so the subsequent steps in the sequence are moot and should be skipped. So, by default, an error at any step of a sequence throws the entire sequence into error mode, and the rest of the normal steps are ignored.</p>

<p>If you <em>do</em> need to have a step where its error is recoverable, there are several different API methods that can accomodate, such as <code>try(..)</code> – previously mentioned as a kind of <code>try..catch</code> step – or <code>until(..)</code> – a retry loop that keeps attempting the step until it succeeds or you manually <code>break()</code> the loop. <em>asynquence</em> even has <code>pThen(..)</code> and <code>pCatch(..)</code> methods, which work identically to how normal Promise <code>then(..)</code> and <code>catch(..)</code> work (see Chapter 3), so you can do localized mid-sequence error handling if you so choose.</p>

<p>The point is, you have both options, but the more common one in my experience is the default. With Promises, to get a chain of steps to ignore all steps once an error occurs, you have to take care not to register a rejection handler at any step; otherwise, that error gets swallowed as handled, and the sequence may continue (perhaps unexpectedly). This kind of desired behavior is a bit awkward to properly and reliably handle.</p>

<p>To register a sequence error notification handler, <em>asynquence</em> provides an <code>or(..)</code> sequence method, which also has an alias of <code>onerror(..)</code>. You can call this method anywhere in the sequence, and you can register as many handlers as you’d like. That makes it easy for multiple different consumers to listen in on a sequence to know if it failed or not; it’s kind of like an error event handler in that respect.</p>

<p>Just like with Promises, all JS exceptions become sequence errors, or you can programmatically signal a sequence error:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> sq = ASQ( <span style="color:#080;font-weight:bold">function</span>(done){
        setTimeout( <span style="color:#080;font-weight:bold">function</span>(){
                <span style="color:#777">// signal an error for the sequence</span>
                done.fail( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Oops</span><span style="color:#710">&quot;</span></span> );
        }, <span style="color:#00D">100</span> );
} )
.then( <span style="color:#080;font-weight:bold">function</span>(done){
        <span style="color:#777">// will never get here</span>
} )
.or( <span style="color:#080;font-weight:bold">function</span>(err){
        console.log( err );                        <span style="color:#777">// Oops</span>
} )
.then( <span style="color:#080;font-weight:bold">function</span>(done){
        <span style="color:#777">// won't get here either</span>
} );

<span style="color:#777">// later</span>

sq.or( <span style="color:#080;font-weight:bold">function</span>(err){
        console.log( err );                        <span style="color:#777">// Oops</span>
} );
</pre></div>
</div>
</div>

<p>Another really important difference with error handling in <em>asynquence</em> compared to native Promises is the default behavior of “unhandled exceptions”. As we discussed at length in Chapter 3, a rejected Promise without a registered rejection handler will just silently hold (aka swallow) the error; you have to remember to always end a chain with a final <code>catch(..)</code>.</p>

<p>In <em>asynquence</em>, the assumption is reversed.</p>

<p>If an error occurs on a sequence, and it <strong>at that moment</strong> has no error handlers registered, the error is reported to the <code>console</code>. In other words, unhandled rejections are by default always reported so as not to be swallowed and missed.</p>

<p>As soon as you register an error handler against a sequence, it opts that sequence out of such reporting, to prevent duplicate noise.</p>

<p>There may, in fact, be cases where you want to create a sequence that may go into the error state before you have a chance to register the handler. This isn’t common, but it can happen from time to time.</p>

<p>In those cases, you can also <strong>opt a sequence instance out</strong> of error reporting by calling <code>defer()</code> on the sequence. You should only opt out of error reporting if you are sure that you’re going to eventually handle such errors:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> sq1 = ASQ( <span style="color:#080;font-weight:bold">function</span>(done){
        doesnt.Exist();                        <span style="color:#777">// will throw exception to console</span>
} );

<span style="color:#080;font-weight:bold">var</span> sq2 = ASQ( <span style="color:#080;font-weight:bold">function</span>(done){
        doesnt.Exist();                        <span style="color:#777">// will throw only a sequence error</span>
} )
<span style="color:#777">// opt-out of error reporting</span>
.defer();

setTimeout( <span style="color:#080;font-weight:bold">function</span>(){
        sq1.or( <span style="color:#080;font-weight:bold">function</span>(err){
                console.log( err );        <span style="color:#777">// ReferenceError</span>
        } );

        sq2.or( <span style="color:#080;font-weight:bold">function</span>(err){
                console.log( err );        <span style="color:#777">// ReferenceError</span>
        } );
}, <span style="color:#00D">100</span> );

<span style="color:#777">// ReferenceError (from sq1)</span>
</pre></div>
</div>
</div>

<p>This is better error handling behavior than Promises themselves have, because it’s the Pit of Success, not the Pit of Failure (see Chapter 3).</p>

<p><strong>Note:</strong> If a sequence is piped into (aka subsumed by) another sequence – see “Combining Sequences”  for a complete description – then the source sequence is opted out of error reporting, but now the target sequence’s error reporting or lack thereof must be considered.</p>

<h3 id="parallel-steps">Parallel Steps</h3>

<p>Not all steps in your sequences will have just a single (async) task to perform; some will need to perform multiple steps “in parallel” (concurrently). A step in a sequence in which multiple substeps are processing concurrently is called a <code>gate(..)</code> – there’s an <code>all(..)</code> alias if you prefer – and is directly symmetric to native <code>Promise.all([..])</code>.</p>

<p>If all the steps in the <code>gate(..)</code> complete successfully, all success messages will be passed to the next sequence step. If any of them generate errors, the whole sequence immediately goes into an error state.</p>

<p>Consider:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>ASQ( <span style="color:#080;font-weight:bold">function</span>(done){
        setTimeout( done, <span style="color:#00D">100</span> );
} )
.gate(
        <span style="color:#080;font-weight:bold">function</span>(done){
                setTimeout( <span style="color:#080;font-weight:bold">function</span>(){
                        done( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Hello</span><span style="color:#710">&quot;</span></span> );
                }, <span style="color:#00D">100</span> );
        },
        <span style="color:#080;font-weight:bold">function</span>(done){
                setTimeout( <span style="color:#080;font-weight:bold">function</span>(){
                        done( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">World</span><span style="color:#710">&quot;</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">!</span><span style="color:#710">&quot;</span></span> );
                }, <span style="color:#00D">100</span> );
        }
)
.val( <span style="color:#080;font-weight:bold">function</span>(msg1,msg2){
        console.log( msg1 );        <span style="color:#777">// Hello</span>
        console.log( msg2 );        <span style="color:#777">// [ &quot;World&quot;, &quot;!&quot; ]</span>
} );
</pre></div>
</div>
</div>

<p>For illustration, let’s compare that example to native Promises:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">new</span> Promise( <span style="color:#080;font-weight:bold">function</span>(resolve,reject){
        setTimeout( resolve, <span style="color:#00D">100</span> );
} )
.then( <span style="color:#080;font-weight:bold">function</span>(){
        <span style="color:#080;font-weight:bold">return</span> Promise.all( [
                <span style="color:#080;font-weight:bold">new</span> Promise( <span style="color:#080;font-weight:bold">function</span>(resolve,reject){
                        setTimeout( <span style="color:#080;font-weight:bold">function</span>(){
                                resolve( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Hello</span><span style="color:#710">&quot;</span></span> );
                        }, <span style="color:#00D">100</span> );
                } ),
                <span style="color:#080;font-weight:bold">new</span> Promise( <span style="color:#080;font-weight:bold">function</span>(resolve,reject){
                        setTimeout( <span style="color:#080;font-weight:bold">function</span>(){
                                <span style="color:#777">// note: we need a [ ] array here</span>
                                resolve( [ <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">World</span><span style="color:#710">&quot;</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">!</span><span style="color:#710">&quot;</span></span> ] );
                        }, <span style="color:#00D">100</span> );
                } )
        ] );
} )
.then( <span style="color:#080;font-weight:bold">function</span>(msgs){
        console.log( msgs[<span style="color:#00D">0</span>] );        <span style="color:#777">// Hello</span>
        console.log( msgs[<span style="color:#00D">1</span>] );        <span style="color:#777">// [ &quot;World&quot;, &quot;!&quot; ]</span>
} );
</pre></div>
</div>
</div>

<p>Yuck. Promises require a lot more boilerplate overhead to express the same asynchronous flow control. That’s a great illustration of why the <em>asynquence</em> API and abstraction make dealing with Promise steps a lot nicer. The improvement only goes higher the more complex your asynchrony is.</p>

<h4 id="step-variations">Step Variations</h4>

<p>There are several variations in the contrib plug-ins on <em>asynquence</em>’s <code>gate(..)</code> step type that can be quite helpful:</p>

<ul>
  <li><code>any(..)</code> is like <code>gate(..)</code>, except just one segment has to eventually succeed to proceed on the main sequence.</li>
  <li><code>first(..)</code> is like <code>any(..)</code>, except as soon as any segment succeeds, the main sequence proceeds (ignoring subsequent results from other segments).</li>
  <li><code>race(..)</code> (symmetric with <code>Promise.race([..])</code>) is like <code>first(..)</code>, except the main sequence proceeds as soon as any segment completes (either success or failure).</li>
  <li><code>last(..)</code> is like <code>any(..)</code>, except only the latest segment to complete successfully sends its message(s) along to the main sequence.</li>
  <li><code>none(..)</code> is the inverse of <code>gate(..)</code>: the main sequence proceeds only if all the segments fail (with all segment error message(s) transposed as success message(s) and vice versa).</li>
</ul>

<p>Let’s first define some helpers to make illustration cleaner:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">success1</span>(done) {
        setTimeout( <span style="color:#080;font-weight:bold">function</span>(){
                done( <span style="color:#00D">1</span> );
        }, <span style="color:#00D">100</span> );
}

<span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">success2</span>(done) {
        setTimeout( <span style="color:#080;font-weight:bold">function</span>(){
                done( <span style="color:#00D">2</span> );
        }, <span style="color:#00D">100</span> );
}

<span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">failure3</span>(done) {
        setTimeout( <span style="color:#080;font-weight:bold">function</span>(){
                done.fail( <span style="color:#00D">3</span> );
        }, <span style="color:#00D">100</span> );
}

<span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">output</span>(msg) {
        console.log( msg );
}
</pre></div>
</div>
</div>

<p>Now, let’s demonstrate these <code>gate(..)</code> step variations:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>ASQ().race(
        failure3,
        success1
)
.or( output );                <span style="color:#777">// 3</span>


ASQ().any(
        success1,
        failure3,
        success2
)
.val( <span style="color:#080;font-weight:bold">function</span>(){
        <span style="color:#080;font-weight:bold">var</span> args = [].slice.call( <span style="color:#950">arguments</span> );
        console.log(
                args                <span style="color:#777">// [ 1, undefined, 2 ]</span>
        );
} );


ASQ().first(
        failure3,
        success1,
        success2
)
.val( output );                <span style="color:#777">// 1</span>


ASQ().last(
        failure3,
        success1,
        success2
)
.val( output );                <span style="color:#777">// 2</span>

ASQ().none(
        failure3
)
.val( output )                <span style="color:#777">// 3</span>
.none(
        failure3
        success1
)
.or( output );                <span style="color:#777">// 1</span>
</pre></div>
</div>
</div>

<p>Another step variation is <code>map(..)</code>, which lets you asynchronously map elements of an array to different values, and the step doesn’t proceed until all the mappings are complete. <code>map(..)</code> is very similar to <code>gate(..)</code>, except it gets the initial values from an array instead of from separately specified functions, and also because you define a single function callback to operate on each value:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">function</span> <span style="color:#080;font-weight:bold">double</span>(x,done) {
        setTimeout( <span style="color:#080;font-weight:bold">function</span>(){
                done( x * <span style="color:#00D">2</span> );
        }, <span style="color:#00D">100</span> );
}

ASQ().map( [<span style="color:#00D">1</span>,<span style="color:#00D">2</span>,<span style="color:#00D">3</span>], <span style="color:#080;font-weight:bold">double</span> )
.val( output );                                        <span style="color:#777">// [2,4,6]</span>
</pre></div>
</div>
</div>

<p>Also, <code>map(..)</code> can receive either of its parameters (the array or the callback) from messages passed from the previous step:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">plusOne</span>(x,done) {
        setTimeout( <span style="color:#080;font-weight:bold">function</span>(){
                done( x + <span style="color:#00D">1</span> );
        }, <span style="color:#00D">100</span> );
}

ASQ( [<span style="color:#00D">1</span>,<span style="color:#00D">2</span>,<span style="color:#00D">3</span>] )
.map( <span style="color:#080;font-weight:bold">double</span> )                        <span style="color:#777">// message `[1,2,3]` comes in</span>
.map( plusOne )                        <span style="color:#777">// message `[2,4,6]` comes in</span>
.val( output );                        <span style="color:#777">// [3,5,7]</span>
</pre></div>
</div>
</div>

<p>Another variation is <code>waterfall(..)</code>, which is kind of like a mixture between <code>gate(..)</code>’s message collection behavior but <code>then(..)</code>’s sequential processing.</p>

<p>Step 1 is first executed, then the success message from step 1 is given to step 2, and then both success messages go to step 3, and then all three success messages go to step 4, and so on, such that the messages sort of collect and cascade down the “waterfall”.</p>

<p>Consider:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">function</span> <span style="color:#080;font-weight:bold">double</span>(done) {
        <span style="color:#080;font-weight:bold">var</span> args = [].slice.call( <span style="color:#950">arguments</span>, <span style="color:#00D">1</span> );
        console.log( args );

        setTimeout( <span style="color:#080;font-weight:bold">function</span>(){
                done( args[args.length - <span style="color:#00D">1</span>] * <span style="color:#00D">2</span> );
        }, <span style="color:#00D">100</span> );
}

ASQ( <span style="color:#00D">3</span> )
.waterfall(
        <span style="color:#080;font-weight:bold">double</span>,                                        <span style="color:#777">// [ 3 ]</span>
        <span style="color:#080;font-weight:bold">double</span>,                                        <span style="color:#777">// [ 6 ]</span>
        <span style="color:#080;font-weight:bold">double</span>,                                        <span style="color:#777">// [ 6, 12 ]</span>
        <span style="color:#080;font-weight:bold">double</span>                                        <span style="color:#777">// [ 6, 12, 24 ]</span>
)
.val( <span style="color:#080;font-weight:bold">function</span>(){
        <span style="color:#080;font-weight:bold">var</span> args = [].slice.call( <span style="color:#950">arguments</span> );
        console.log( args );        <span style="color:#777">// [ 6, 12, 24, 48 ]</span>
} );
</pre></div>
</div>
</div>

<p>If at any point in the “waterfall” an error occurs, the whole sequence immediately goes into an error state.</p>

<h4 id="error-tolerance">Error Tolerance</h4>

<p>Sometimes you want to manage errors at the step level and not let them necessarily send the whole sequence into the error state. <em>asynquence</em> offers two step variations for that purpose.</p>

<p><code>try(..)</code> attempts a step, and if it succeeds, the sequence proceeds as normal, but if the step fails, the failure is turned into a success message formated as <code>{ catch: .. }</code> with the error message(s) filled in:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>ASQ()
.<span style="color:#080;font-weight:bold">try</span>( success1 )
.val( output )                        <span style="color:#777">// 1</span>
.<span style="color:#080;font-weight:bold">try</span>( failure3 )
.val( output )                        <span style="color:#777">// { catch: 3 }</span>
.or( <span style="color:#080;font-weight:bold">function</span>(err){
        <span style="color:#777">// never gets here</span>
} );
</pre></div>
</div>
</div>

<p>You could instead set up a retry loop using <code>until(..)</code>, which tries the step and if it fails, retries the step again on the next event loop tick, and so on.</p>

<p>This retry loop can continue indefinitely, but if you want to break out of the loop, you can call the <code>break()</code> flag on the completion trigger, which sends the main sequence into an error state:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> count = <span style="color:#00D">0</span>;

ASQ( <span style="color:#00D">3</span> )
.until( <span style="color:#080;font-weight:bold">double</span> )
.val( output )                                        <span style="color:#777">// 6</span>
.until( <span style="color:#080;font-weight:bold">function</span>(done){
        count++;

        setTimeout( <span style="color:#080;font-weight:bold">function</span>(){
                <span style="color:#080;font-weight:bold">if</span> (count &lt; <span style="color:#00D">5</span>) {
                        done.fail();
                }
                <span style="color:#080;font-weight:bold">else</span> {
                        <span style="color:#777">// break out of the `until(..)` retry loop</span>
                        done.<span style="color:#080;font-weight:bold">break</span>( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Oops</span><span style="color:#710">&quot;</span></span> );
                }
        }, <span style="color:#00D">100</span> );
} )
.or( output );                                        <span style="color:#777">// Oops</span>
</pre></div>
</div>
</div>

<h4 id="promise-style-steps">Promise-Style Steps</h4>

<p>If you would prefer to have, inline in your sequence, Promise-style semantics like Promises’ <code>then(..)</code> and <code>catch(..)</code> (see Chapter 3), you can use the <code>pThen</code> and <code>pCatch</code> plug-ins:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>ASQ( <span style="color:#00D">21</span> )
.pThen( <span style="color:#080;font-weight:bold">function</span>(msg){
        <span style="color:#080;font-weight:bold">return</span> msg * <span style="color:#00D">2</span>;
} )
.pThen( output )                                <span style="color:#777">// 42</span>
.pThen( <span style="color:#080;font-weight:bold">function</span>(){
        <span style="color:#777">// throw an exception</span>
        doesnt.Exist();
} )
.pCatch( <span style="color:#080;font-weight:bold">function</span>(err){
        <span style="color:#777">// caught the exception (rejection)</span>
        console.log( err );                        <span style="color:#777">// ReferenceError</span>
} )
.val( <span style="color:#080;font-weight:bold">function</span>(){
        <span style="color:#777">// main sequence is back in a</span>
        <span style="color:#777">// success state because previous</span>
        <span style="color:#777">// exception was caught by</span>
        <span style="color:#777">// `pCatch(..)`</span>
} );
</pre></div>
</div>
</div>

<p><code>pThen(..)</code> and <code>pCatch(..)</code> are designed to run in the sequence, but behave as if it was a normal Promise chain. As such, you can either resolve genuine Promises or <em>asynquence</em> sequences from the “fulfillment” handler passed to <code>pThen(..)</code> (see Chapter 3).</p>

<h3 id="forking-sequences">Forking Sequences</h3>

<p>One feature that can be quite useful about Promises is that you can attach multiple <code>then(..)</code> handler registrations to the same promise, effectively “forking” the flow-control at that promise:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> p = Promise.resolve( <span style="color:#00D">21</span> );

<span style="color:#777">// fork 1 (from `p`)</span>
p.then( <span style="color:#080;font-weight:bold">function</span>(msg){
        <span style="color:#080;font-weight:bold">return</span> msg * <span style="color:#00D">2</span>;
} )
.then( <span style="color:#080;font-weight:bold">function</span>(msg){
        console.log( msg );                <span style="color:#777">// 42</span>
} )

<span style="color:#777">// fork 2 (from `p`)</span>
p.then( <span style="color:#080;font-weight:bold">function</span>(msg){
        console.log( msg );                <span style="color:#777">// 21</span>
} );
</pre></div>
</div>
</div>

<p>The same “forking” is easy in <em>asynquence</em> with <code>fork()</code>:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> sq = ASQ(..).then(..).then(..);

<span style="color:#080;font-weight:bold">var</span> sq2 = sq.fork();

<span style="color:#777">// fork 1</span>
sq.then(..)..;

<span style="color:#777">// fork 2</span>
sq2.then(..)..;
</pre></div>
</div>
</div>

<h3 id="combining-sequences">Combining Sequences</h3>

<p>The reverse of <code>fork()</code>ing, you can combine two sequences by subsuming one into another, using the <code>seq(..)</code> instance method:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> sq = ASQ( <span style="color:#080;font-weight:bold">function</span>(done){
        setTimeout( <span style="color:#080;font-weight:bold">function</span>(){
                done( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Hello World</span><span style="color:#710">&quot;</span></span> );
        }, <span style="color:#00D">200</span> );
} );

ASQ( <span style="color:#080;font-weight:bold">function</span>(done){
        setTimeout( done, <span style="color:#00D">100</span> );
} )
<span style="color:#777">// subsume `sq` sequence into this sequence</span>
.seq( sq )
.val( <span style="color:#080;font-weight:bold">function</span>(msg){
        console.log( msg );                <span style="color:#777">// Hello World</span>
} )
</pre></div>
</div>
</div>

<p><code>seq(..)</code> can either accept a sequence itself, as shown here, or a function. If a function, it’s expected that the function when called will return a sequence, so the preceding code could have been done with:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#777">// ..</span>
.seq( <span style="color:#080;font-weight:bold">function</span>(){
        <span style="color:#080;font-weight:bold">return</span> sq;
} )
<span style="color:#777">// ..</span>
</pre></div>
</div>
</div>

<p>Also, that step could instead have been accomplished with a <code>pipe(..)</code>:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#777">// ..</span>
.then( <span style="color:#080;font-weight:bold">function</span>(done){
        <span style="color:#777">// pipe `sq` into the `done` continuation callback</span>
        sq.pipe( done );
} )
<span style="color:#777">// ..</span>
</pre></div>
</div>
</div>

<p>When a sequence is subsumed, both its success message stream and its error stream are piped in.</p>

<p><strong>Note:</strong> As mentioned in an earlier note, piping (manually with <code>pipe(..)</code> or automatically with <code>seq(..)</code>) opts the source sequence out of error-reporting, but doesn’t affect the error reporting status of the target sequence.</p>

<h2 id="value-and-error-sequences">Value and Error Sequences</h2>

<p>If any step of a sequence is just a normal value, that value is just mapped to that step’s completion message:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> sq = ASQ( <span style="color:#00D">42</span> );

sq.val( <span style="color:#080;font-weight:bold">function</span>(msg){
        console.log( msg );                <span style="color:#777">// 42</span>
} );
</pre></div>
</div>
</div>

<p>If you want to make a sequence that’s automatically errored:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> sq = ASQ.failed( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Oops</span><span style="color:#710">&quot;</span></span> );

ASQ()
.seq( sq )
.val( <span style="color:#080;font-weight:bold">function</span>(msg){
        <span style="color:#777">// won't get here</span>
} )
.or( <span style="color:#080;font-weight:bold">function</span>(err){
        console.log( err );                <span style="color:#777">// Oops</span>
} );
</pre></div>
</div>
</div>

<p>You also may want to automatically create a delayed-value or a delayed-error sequence. Using the <code>after</code> and <code>failAfter</code> contrib plug-ins, this is easy:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> sq1 = ASQ.after( <span style="color:#00D">100</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Hello</span><span style="color:#710">&quot;</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">World</span><span style="color:#710">&quot;</span></span> );
<span style="color:#080;font-weight:bold">var</span> sq2 = ASQ.failAfter( <span style="color:#00D">100</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Oops</span><span style="color:#710">&quot;</span></span> );

sq1.val( <span style="color:#080;font-weight:bold">function</span>(msg1,msg2){
        console.log( msg1, msg2 );                <span style="color:#777">// Hello World</span>
} );

sq2.or( <span style="color:#080;font-weight:bold">function</span>(err){
        console.log( err );                                <span style="color:#777">// Oops</span>
} );
</pre></div>
</div>
</div>

<p>You can also insert a delay in the middle of a sequence using <code>after(..)</code>:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>ASQ( <span style="color:#00D">42</span> )
<span style="color:#777">// insert a delay into the sequence</span>
.after( <span style="color:#00D">100</span> )
.val( <span style="color:#080;font-weight:bold">function</span>(msg){
        console.log( msg );                <span style="color:#777">// 42</span>
} );
</pre></div>
</div>
</div>

<h2 id="promises-and-callbacks">Promises and Callbacks</h2>

<p>I think <em>asynquence</em> sequences provide a lot of value on top of native Promises, and for the most part you’ll find it more pleasant and more powerful to work at that level of abstration. However, integrating <em>asynquence</em> with other non-<em>asynquence</em> code will be a reality.</p>

<p>You can easily subsume a promise (e.g., thenable – see Chapter 3) into a sequence using the <code>promise(..)</code> instance method:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> p = Promise.resolve( <span style="color:#00D">42</span> );

ASQ()
.promise( p )                        <span style="color:#777">// could also: `function(){ return p; }`</span>
.val( <span style="color:#080;font-weight:bold">function</span>(msg){
        console.log( msg );        <span style="color:#777">// 42</span>
} );
</pre></div>
</div>
</div>

<p>And to go the opposite direction and fork/vend a promise from a sequence at a certain step, use the <code>toPromise</code> contrib plug-in:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> sq = ASQ.after( <span style="color:#00D">100</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Hello World</span><span style="color:#710">&quot;</span></span> );

sq.toPromise()
<span style="color:#777">// this is a standard promise chain now</span>
.then( <span style="color:#080;font-weight:bold">function</span>(msg){
        <span style="color:#080;font-weight:bold">return</span> msg.toUpperCase();
} )
.then( <span style="color:#080;font-weight:bold">function</span>(msg){
        console.log( msg );                <span style="color:#777">// HELLO WORLD</span>
} );
</pre></div>
</div>
</div>

<p>To adapt <em>asynquence</em> to systems using callbacks, there are several helper facilities. To automatically generate an “error-first style” callback from your sequence to wire into a callback-oriented utility, use <code>errfcb</code>:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> sq = ASQ( <span style="color:#080;font-weight:bold">function</span>(done){
        <span style="color:#777">// note: expecting &quot;error-first style&quot; callback</span>
        someAsyncFuncWithCB( <span style="color:#00D">1</span>, <span style="color:#00D">2</span>, done.errfcb )
} )
.val( <span style="color:#080;font-weight:bold">function</span>(msg){
        <span style="color:#777">// ..</span>
} )
.or( <span style="color:#080;font-weight:bold">function</span>(err){
        <span style="color:#777">// ..</span>
} );

<span style="color:#777">// note: expecting &quot;error-first style&quot; callback</span>
anotherAsyncFuncWithCB( <span style="color:#00D">1</span>, <span style="color:#00D">2</span>, sq.errfcb() );
</pre></div>
</div>
</div>

<p>You also may want to create a sequence-wrapped version of a utility – compare to “promisory” in Chapter 3 and “thunkory” in Chapter 4 – and <em>asynquence</em> provides <code>ASQ.wrap(..)</code> for that purpose:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> coolUtility = ASQ.wrap( someAsyncFuncWithCB );

coolUtility( <span style="color:#00D">1</span>, <span style="color:#00D">2</span> )
.val( <span style="color:#080;font-weight:bold">function</span>(msg){
        <span style="color:#777">// ..</span>
} )
.or( <span style="color:#080;font-weight:bold">function</span>(err){
        <span style="color:#777">// ..</span>
} );
</pre></div>
</div>
</div>

<p><strong>Note:</strong> For the sake of clarity (and for fun!), let’s coin yet another term, for a sequence-producing function that comes from <code>ASQ.wrap(..)</code>, like <code>coolUtility</code> here. I propose “sequory” (“sequence” + “factory”).</p>

<h2 id="iterable-sequences">Iterable Sequences</h2>

<p>The normal paradigm for a sequence is that each step is responsible for completing itself, which is what advances the sequence. Promises work the same way.</p>

<p>The unfortunate part is that sometimes you need external control over a Promise/step, which leads to awkward “capability extraction”.</p>

<p>Consider this Promises example:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> domready = <span style="color:#080;font-weight:bold">new</span> Promise( <span style="color:#080;font-weight:bold">function</span>(resolve,reject){
        <span style="color:#777">// don't want to put this here, because</span>
        <span style="color:#777">// it belongs logically in another part</span>
        <span style="color:#777">// of the code</span>
        document.addEventListener( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">DOMContentLoaded</span><span style="color:#710">&quot;</span></span>, resolve );
} );

<span style="color:#777">// ..</span>

domready.then( <span style="color:#080;font-weight:bold">function</span>(){
        <span style="color:#777">// DOM is ready!</span>
} );
</pre></div>
</div>
</div>

<p>The “capability extraction” anti-pattern with Promises looks like this:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> ready;

<span style="color:#080;font-weight:bold">var</span> domready = <span style="color:#080;font-weight:bold">new</span> Promise( <span style="color:#080;font-weight:bold">function</span>(resolve,reject){
        <span style="color:#777">// extract the `resolve()` capability</span>
        ready = resolve;
} );

<span style="color:#777">// ..</span>

domready.then( <span style="color:#080;font-weight:bold">function</span>(){
        <span style="color:#777">// DOM is ready!</span>
} );

<span style="color:#777">// ..</span>

document.addEventListener( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">DOMContentLoaded</span><span style="color:#710">&quot;</span></span>, ready );
</pre></div>
</div>
</div>

<p><strong>Note:</strong> This anti-pattern is an awkward code smell, in my opinion, but some developers like it, for reasons I can’t grasp.</p>

<p><em>asynquence</em> offers an inverted sequence type I call “iterable sequences”, which externalizes the control capability (it’s quite useful in use cases like the <code>domready</code>):</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#777">// note: `domready` here is an *iterator* that</span>
<span style="color:#777">// controls the sequence</span>
<span style="color:#080;font-weight:bold">var</span> domready = ASQ.iterable();

<span style="color:#777">// ..</span>

domready.val( <span style="color:#080;font-weight:bold">function</span>(){
        <span style="color:#777">// DOM is ready</span>
} );

<span style="color:#777">// ..</span>

document.addEventListener( <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">DOMContentLoaded</span><span style="color:#710">&quot;</span></span>, domready.next );
</pre></div>
</div>
</div>

<p>There’s more to iterable sequences than what we see in this scenario. We’ll come back to them in Appendix B.</p>

<h2 id="running-generators">Running Generators</h2>

<p>In Chapter 4, we derived a utility called <code>run(..)</code> which can run generators to completion, listening for <code>yield</code>ed Promises and using them to async resume the generator. <em>asynquence</em> has just such a utility built in, called <code>runner(..)</code>.</p>

<p>Let’s first set up some helpers for illustration:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">doublePr</span>(x) {
        <span style="color:#080;font-weight:bold">return</span> <span style="color:#080;font-weight:bold">new</span> Promise( <span style="color:#080;font-weight:bold">function</span>(resolve,reject){
                setTimeout( <span style="color:#080;font-weight:bold">function</span>(){
                        resolve( x * <span style="color:#00D">2</span> );
                }, <span style="color:#00D">100</span> );
        } );
}

<span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">doubleSeq</span>(x) {
        <span style="color:#080;font-weight:bold">return</span> ASQ( <span style="color:#080;font-weight:bold">function</span>(done){
                setTimeout( <span style="color:#080;font-weight:bold">function</span>(){
                        done( x * <span style="color:#00D">2</span>)
                }, <span style="color:#00D">100</span> );
        } );
}
</pre></div>
</div>
</div>

<p>Now, we can use <code>runner(..)</code> as a step in the middle of a sequence:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre>ASQ( <span style="color:#00D">10</span>, <span style="color:#00D">11</span> )
.runner( <span style="color:#080;font-weight:bold">function</span>*(token){
        <span style="color:#080;font-weight:bold">var</span> x = token.messages[<span style="color:#00D">0</span>] + token.messages[<span style="color:#00D">1</span>];

        <span style="color:#777">// yield a real promise</span>
        x = yield doublePr( x );

        <span style="color:#777">// yield a sequence</span>
        x = yield doubleSeq( x );

        <span style="color:#080;font-weight:bold">return</span> x;
} )
.val( <span style="color:#080;font-weight:bold">function</span>(msg){
        console.log( msg );                        <span style="color:#777">// 84</span>
} );
</pre></div>
</div>
</div>

<h3 id="wrapped-generators">Wrapped Generators</h3>

<p>You can also create a self-packaged generator – that is, a normal function that runs your specified generator and returns a sequence for its completion – by <code>ASQ.wrap(..)</code>ing it:</p>

<div class="highlighter-coderay"><div class="CodeRay">
  <div class="code"><pre><span style="color:#080;font-weight:bold">var</span> foo = ASQ.wrap( <span style="color:#080;font-weight:bold">function</span>*(token){
        <span style="color:#080;font-weight:bold">var</span> x = token.messages[<span style="color:#00D">0</span>] + token.messages[<span style="color:#00D">1</span>];

        <span style="color:#777">// yield a real promise</span>
        x = yield doublePr( x );

        <span style="color:#777">// yield a sequence</span>
        x = yield doubleSeq( x );

        <span style="color:#080;font-weight:bold">return</span> x;
}, { <span style="color:#606">gen</span>: <span style="color:#069">true</span> } );

<span style="color:#777">// ..</span>

foo( <span style="color:#00D">8</span>, <span style="color:#00D">9</span> )
.val( <span style="color:#080;font-weight:bold">function</span>(msg){
        console.log( msg );                        <span style="color:#777">// 68</span>
} );
</pre></div>
</div>
</div>

<p>There’s a lot more awesome that <code>runner(..)</code> is capable of, but we’ll come back to that in Appendix B.</p>

<h2 id="review">Review</h2>

<p><em>asynquence</em> is a simple abstraction – a sequence is a series of (async) steps – on top of Promises, aimed at making working with various asynchronous patterns much easier, without any compromise in capability.</p>

<p>There are other goodies in the <em>asynquence</em> core API and its contrib plug-ins beyond what we saw in this appendix, but we’ll leave that as an exercise for the reader to go check the rest of the capabilities out.</p>

<p>You’ve now seen the essence and spirit of <em>asynquence</em>. The key take away is that a sequence is comprised of steps, and those steps can be any of dozens of different variations on Promises, or they can be a generator-run, or… The choice is up to you, you have all the freedom to weave together whatever async flow control logic is appropriate for your tasks. No more library switching to catch different async patterns.</p>

<p>If these <em>asynquence</em> snippets have made sense to you, you’re now pretty well up to speed on the library; it doesn’t take that much to learn, actually!</p>

<p>If you’re still a little fuzzy on how it works (or why!), you’ll want to spend a little more time examining the previous examples and playing around with <em>asynquence</em> yourself, before going on to the next appendix. Appendix B will push <em>asynquence</em> into several more advanced and powerful async patterns.</p>

    </div>
  </body>
</html>
